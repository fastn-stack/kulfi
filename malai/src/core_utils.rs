/// Simple remote access utilities for CLI commands
/// This module provides the basic functionality needed for remote access commands
/// without the complex fastn-p2p integration

use eyre::Result;
use std::path::PathBuf;
use std::str::FromStr;

/// Get MALAI_HOME directory with proper defaults
pub fn get_malai_home() -> PathBuf {
    if let Ok(malai_home) = std::env::var("MALAI_HOME") {
        PathBuf::from(malai_home)
    } else {
        get_default_malai_home()
    }
}

/// Get default MALAI_HOME directory based on platform
pub fn get_default_malai_home() -> PathBuf {
    if let Some(data_dir) = dirs::data_dir() {
        data_dir.join("malai")
    } else {
        // Fallback to current directory
        std::env::current_dir().unwrap_or_default().join(".malai")
    }
}

/// Initialize cluster with required cluster name
pub async fn init_cluster(cluster_name: String) -> Result<()> {
    println!("ğŸ—ï¸  Creating cluster...");
    
    let malai_home = get_malai_home();
    let cluster_dir = malai_home.join("clusters").join(&cluster_name);
    
    // Ensure cluster directory exists
    std::fs::create_dir_all(&cluster_dir)?;
    
    // Generate cluster manager identity (design-compliant: cluster.private-key)
    let cluster_private_key_file = cluster_dir.join("cluster.private-key");
    let (cluster_manager_id52, _cluster_manager_secret) = if cluster_private_key_file.exists() {
        // Read existing cluster manager identity
        let secret_key_hex = std::fs::read_to_string(&cluster_private_key_file)?;
        let secret_key = fastn_id52::SecretKey::from_str(&secret_key_hex.trim())?;
        let id52 = secret_key.id52();
        (id52, secret_key)
    } else {
        // Generate new cluster manager identity
        let secret_key = fastn_id52::SecretKey::generate();
        let id52 = secret_key.id52();
        // Save to cluster.private-key (design-compliant)
        std::fs::write(&cluster_private_key_file, secret_key.to_string())?;
        (id52, secret_key)
    };
    
    println!("ğŸ“ Generated cluster manager identity: {}", cluster_manager_id52);
    
    // Create basic cluster config  
    let cluster_config = format!(
        r#"# Malai Cluster Configuration
# Generated by: malai cluster init {}
# Cluster Name: {}
# Cluster Manager: {}

[cluster_manager]
id52 = "{}"
cluster_name = "{}"
use_keyring = true

# Add machines to this cluster by editing this file
# Examples:

# Basic machine (accepts remote access)
# [machine.web01]
# id52 = "machine-id52-here"
# accept_ssh = true
# allow_from = "*"

# With command aliases
# [machine.web01.command.restart-nginx]
# allow_from = "admins"
# command = "sudo systemctl restart nginx"

# With HTTP services  
# [machine.web01.http.admin]
# port = 8080
# allow_from = "admins"
# secure = false
"#,
        cluster_name,
        cluster_name,
        cluster_manager_id52,
        cluster_manager_id52,
        cluster_name
    );
    
    let config_path = cluster_dir.join("cluster.toml");
    std::fs::write(&config_path, cluster_config)?;
    
    println!("âœ… Cluster configuration created at: {}", config_path.display());
    println!("Cluster created with ID: {}", cluster_manager_id52);
    println!("Cluster name: {}", cluster_name);
    
    // Trigger selective rescan for the new cluster
    println!("ğŸ”„ Triggering daemon rescan for new cluster...");
    match crate::config_manager::reload_daemon_config_selective(cluster_name).await {
        Ok(_) => {
            println!("âœ… Daemon automatically updated with new cluster");
        }
        Err(e) if e.to_string().contains("no Unix socket found") => {
            // This is expected - daemon not running during init is normal
            println!("ğŸ’¡ Daemon not running - start with: malai daemon");
        }
        Err(e) => {
            // Real daemon communication failure - this should fail loudly
            return Err(eyre::eyre!("Failed to update daemon with new cluster: {}", e));
        }
    }
    
    Ok(())
}

/// Show cluster information
pub async fn show_cluster_info() -> Result<()> {
    println!("ğŸ“‹ Cluster Information:");
    
    let malai_home = get_malai_home();
    let config_path = malai_home.join("cluster-config.toml");
    
    if !config_path.exists() {
        println!("âŒ No cluster configuration found at: {}", config_path.display());
        println!("ğŸ’¡ Create a cluster with: malai ssh create-cluster");
        return Ok(());
    }
    
    // Read config to determine role
    let config_content = std::fs::read_to_string(&config_path)?;
    println!("ğŸ“„ Config path: {}", config_path.display());
    
    // Parse basic info (simple parsing, not full TOML)
    if let Some(manager_line) = config_content.lines().find(|l| l.starts_with("id52 = ") && !l.contains("[machine.")) {
        let cluster_id = manager_line
            .split('"')
            .nth(1)
            .unwrap_or("unknown");
        println!("ğŸ†” Cluster ID: {}", cluster_id);
        
        // Check local identity to determine role
        let identity_file = malai_home.join("keys").join("identity.key");
        if identity_file.exists() {
            if let Ok(secret_key_hex) = std::fs::read_to_string(&identity_file) {
                if let Ok(secret_key) = fastn_id52::SecretKey::from_str(secret_key_hex.trim()) {
                    let local_id52 = secret_key.id52();
            
                    if local_id52 == cluster_id {
                        println!("ğŸ‘‘ Role: cluster-manager");
                    } else if config_content.contains(&local_id52) {
                        // Find machine name
                        for line in config_content.lines() {
                            if line.contains(&local_id52) {
                                if let Some(machine_section) = config_content.lines().rev().find(|l| l.starts_with("[machine.") && config_content[config_content.find(l).unwrap()..].contains(&local_id52)) {
                                    let machine_name = machine_section
                                        .trim_start_matches("[machine.")
                                        .trim_end_matches("]");
                                    
                                    let machine_section_start = config_content.find(machine_section).unwrap();
                                    let machine_config = &config_content[machine_section_start..];
                                    if machine_config.split("[").next().unwrap().contains("accept_ssh = true") {
                                        println!("ğŸ–¥ï¸  Role: remote access server ({})", machine_name);
                                    } else {
                                        println!("ğŸ’» Role: client-only ({})", machine_name);
                                    }
                                    break;
                                }
                            }
                        }
                    } else {
                        println!("â“ Role: unknown (not found in cluster config)");
                    }
                }
            }
        }
    }
    
    Ok(())
}

/// Start malai daemon with lockfile and daemonization
pub async fn start_malai_daemon(environment: bool, foreground: bool) -> Result<()> {
    if environment {
        // Print environment variables for shell integration
        let malai_home = get_malai_home();
        println!("MALAI_HOME={}", malai_home.display());
        println!("MALAI_DAEMON_SOCK={}", malai_home.join("malai.sock").display());
        return Ok(());
    }
    
    let malai_home = get_malai_home();
    println!("ğŸš€ Starting malai daemon...");
    println!("ğŸ“ MALAI_HOME: {}", malai_home.display());
    
    // Acquire exclusive lock (following fastn-rig pattern)
    let lock_path = malai_home.join("malai.lock");
    let lock_file = std::fs::OpenOptions::new()
        .create(true)
        .truncate(false)
        .write(true)
        .open(&lock_path)?;
    
    match lock_file.try_lock() {
        Ok(()) => {
            println!("ğŸ”’ Lock acquired: {}", lock_path.display());
        }
        Err(_) => {
            println!("âŒ Another malai daemon already running at {}", malai_home.display());
            return Ok(());
        }
    }
    
    let _lock_guard = lock_file; // Hold lock for daemon lifetime
    
    // Daemonize unless in foreground mode
    if !foreground {
        println!("ğŸ”„ Daemonizing (use --foreground to stay in terminal)...");
        // TODO: Implement actual fork/daemonize  
        println!("ğŸ“‹ For now running in foreground (daemonization not yet implemented)");
    } else {
        println!("ğŸ“‹ Running in foreground mode");
    }
    
    // Load and validate ALL configs before daemonizing
    let validated_configs = load_and_validate_all_configs(&malai_home).await?;
    println!("âœ… All configurations validated successfully");
    
    println!("âœ… malai daemon started");
    println!("ğŸ’¡ Use 'malai daemon -e' for environment variables");
    println!("ğŸ“¨ malai daemon running. Press Ctrl+C to stop.");
    
    // Start services based on validated configs
    start_services_from_configs(validated_configs).await?;
    
    // Wait for graceful shutdown using fastn-p2p global singleton
    fastn_p2p::cancelled().await;
    
    println!("ğŸ‘‹ malai daemon stopped gracefully");
    Ok(())
}

/// Load and validate all configurations in MALAI_HOME
async fn load_and_validate_all_configs(malai_home: &PathBuf) -> Result<ValidatedConfigs> {
    println!("ğŸ” Loading and validating all configurations...");
    
    let clusters_dir = malai_home.join("clusters");
    let mut cluster_configs = Vec::new();
    let mut machine_configs = Vec::new();
    
    if !clusters_dir.exists() {
        println!("ğŸ“‚ No clusters directory - daemon will run with no clusters");
        return Ok(ValidatedConfigs {
            cluster_configs,
            machine_configs,
            waiting_machines: Vec::new(),
        });
    }
    
    // Scan all cluster directories
    if let Ok(entries) = std::fs::read_dir(&clusters_dir) {
        for entry in entries.flatten() {
            if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {
                let cluster_alias = entry.file_name().to_string_lossy().to_string();
                let cluster_dir = entry.path();
                
                println!("ğŸ“‹ Validating cluster: {}", cluster_alias);
                
                // Check for cluster-config.toml (cluster manager role)
                let config_path = cluster_dir.join("cluster-config.toml");
                if config_path.exists() {
                    match validate_cluster_config(&config_path, &cluster_alias).await {
                        Ok(config) => {
                            cluster_configs.push(config);
                            println!("   âœ… cluster-config.toml validated");
                        }
                        Err(e) => {
                            println!("   âŒ cluster-config.toml validation failed: {}", e);
                            return Err(eyre::eyre!("Invalid cluster config for {}: {}", cluster_alias, e));
                        }
                    }
                }
                
                // Check for machine-config.toml (machine role)  
                let machine_config_path = cluster_dir.join("machine-config.toml");
                if machine_config_path.exists() {
                    match validate_machine_config(&machine_config_path, &cluster_alias).await {
                        Ok(config) => {
                            machine_configs.push(config);
                            println!("   âœ… machine-config.toml validated");
                        }
                        Err(e) => {
                            println!("   âŒ machine-config.toml validation failed: {}", e);
                            return Err(eyre::eyre!("Invalid machine config for {}: {}", cluster_alias, e));
                        }
                    }
                }
                
                // Validate identity.key if present
                let identity_path = cluster_dir.join("identity.key");
                if identity_path.exists() {
                    if let Err(e) = validate_identity_file(&identity_path) {
                        println!("   âŒ identity.key validation failed: {}", e);
                        return Err(eyre::eyre!("Invalid identity for {}: {}", cluster_alias, e));
                    } else {
                        println!("   âœ… identity.key validated");
                    }
                }
            }
        }
    }
    
    println!("âœ… Configuration validation complete:");
    println!("   ğŸ“Š Cluster manager roles: {}", cluster_configs.len());
    println!("   ğŸ“Š Machine roles: {}", machine_configs.len());
    
    // Also check for machines waiting for config (cluster-info.toml without machine-config.toml)
    let mut waiting_machines = Vec::new();
    if let Ok(entries) = std::fs::read_dir(&clusters_dir) {
        for entry in entries.flatten() {
            if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {
                let cluster_alias = entry.file_name().to_string_lossy().to_string();
                let cluster_dir = entry.path();
                
                let cluster_info_path = cluster_dir.join("cluster-info.toml");
                let machine_config_path = cluster_dir.join("machine-config.toml");
                
                // Machine registered but no config received yet
                if cluster_info_path.exists() && !machine_config_path.exists() {
                    waiting_machines.push(WaitingMachine {
                        cluster_alias: cluster_alias.clone(),
                        cluster_dir: cluster_dir.clone(),
                    });
                    println!("   ğŸ“‹ Machine waiting for config in cluster: {}", cluster_alias);
                }
            }
        }
    }
    
    Ok(ValidatedConfigs {
        cluster_configs,
        machine_configs,
        waiting_machines,
    })
}

/// Validated configuration structure
#[derive(Debug)]
struct ValidatedConfigs {
    cluster_configs: Vec<ClusterConfig>,
    machine_configs: Vec<MachineConfig>,
    waiting_machines: Vec<WaitingMachine>,
}

/// Machine waiting for config from cluster manager
#[derive(Debug)]
struct WaitingMachine {
    cluster_alias: String,
    cluster_dir: std::path::PathBuf,
}

/// Cluster manager configuration
#[derive(Debug)]  
struct ClusterConfig {
    cluster_alias: String,
    config_path: std::path::PathBuf,
    config_content: String,
    config_hash: String,
}

/// Machine configuration
#[derive(Debug, Clone)]
struct MachineConfig {
    cluster_alias: String,  
    config_path: std::path::PathBuf,
    config_content: String,
    machine_role: String, // "ssh-daemon" or "client-only"
}

/// Validate cluster config file
async fn validate_cluster_config(config_path: &std::path::Path, cluster_alias: &str) -> Result<ClusterConfig> {
    let config_content = std::fs::read_to_string(config_path)?;
    
    // Basic TOML syntax validation
    let _parsed: toml::Value = toml::from_str(&config_content)
        .map_err(|e| eyre::eyre!("TOML syntax error: {}", e))?;
    
    // TODO: Add semantic validation (machine refs, groups, etc.)
    
    let config_hash = calculate_config_hash(&config_content);
    
    Ok(ClusterConfig {
        cluster_alias: cluster_alias.to_string(),
        config_path: config_path.to_path_buf(),
        config_content,
        config_hash,
    })
}

/// Validate machine config file
async fn validate_machine_config(config_path: &std::path::Path, cluster_alias: &str) -> Result<MachineConfig> {
    let config_content = std::fs::read_to_string(config_path)?;
    
    // Basic TOML syntax validation
    let _parsed: toml::Value = toml::from_str(&config_content)
        .map_err(|e| eyre::eyre!("TOML syntax error: {}", e))?;
    
    // TODO: Determine machine role from config
    let machine_role = "client-only".to_string(); // Placeholder
    
    Ok(MachineConfig {
        cluster_alias: cluster_alias.to_string(),
        config_path: config_path.to_path_buf(),
        config_content,
        machine_role,
    })
}

/// Validate identity key file
fn validate_identity_file(identity_path: &std::path::Path) -> Result<()> {
    let key_content = std::fs::read_to_string(identity_path)?;
    let _secret_key = fastn_id52::SecretKey::from_str(key_content.trim())
        .map_err(|e| eyre::eyre!("Invalid secret key format: {}", e))?;
    
    Ok(())
}

/// Calculate config hash for change detection
fn calculate_config_hash(content: &str) -> String {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    
    let mut hasher = DefaultHasher::new();
    content.hash(&mut hasher);
    format!("{:x}", hasher.finish())
}

/// Scan MALAI_HOME and report configurations  
async fn scan_and_report_configs(malai_home: &PathBuf) -> Result<()> {
    println!("ğŸ” Scanning for configurations...");
    
    let clusters_dir = malai_home.join("clusters");
    
    if !clusters_dir.exists() {
        println!("âŒ No clusters directory found");
        println!("ğŸ’¡ Initialize a cluster: malai cluster init <name>");
        return Ok(());
    }
    
    println!("ğŸ“‚ Clusters directory: {}", clusters_dir.display());
    
    // Simple cluster count for now
    if let Ok(entries) = std::fs::read_dir(&clusters_dir) {
        let cluster_count = entries.filter(|entry| {
            entry.as_ref().map(|e| e.file_type().map(|t| t.is_dir()).unwrap_or(false)).unwrap_or(false)
        }).count();
        
        println!("ğŸ“Š Found {} cluster directories", cluster_count);
    }
    
    Ok(())
}

/// Show detailed daemon and cluster status
pub async fn show_detailed_status() -> Result<()> {
    let malai_home = get_malai_home();
    
    println!("ğŸ“Š malai Status");
    println!("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    println!("ğŸ“ MALAI_HOME: {}", malai_home.display());
    
    // Check daemon status
    let lockfile_path = malai_home.join("malai.lock");
    if lockfile_path.exists() {
        println!("ğŸ”’ Daemon: RUNNING (lockfile exists)");
    } else {
        println!("ğŸ’¤ Daemon: NOT RUNNING");
    }
    
    // Load and show all configs
    match load_and_validate_all_configs(&malai_home).await {
        Ok(configs) => {
            println!("\nğŸ—ï¸  Cluster Configurations:");
            if configs.cluster_configs.is_empty() {
                println!("   âŒ No cluster manager roles");
            } else {
                for cluster_config in &configs.cluster_configs {
                    println!("   ğŸ‘‘ {} (Cluster Manager)", cluster_config.cluster_alias);
                    println!("      ğŸ“„ Config: {}", cluster_config.config_path.display());
                    println!("      ğŸ”¢ Hash: {}", cluster_config.config_hash);
                    
                    // Count machines in cluster
                    let machine_count = cluster_config.config_content.lines()
                        .filter(|line| line.trim().starts_with("[machine.") && !line.trim().starts_with('#'))
                        .count();
                    println!("      ğŸ“Š Machines: {}", machine_count);
                    
                    // Show sync status from state.json
                    let state_path = cluster_config.config_path.parent().unwrap().join("state.json");
                    if state_path.exists() {
                        if let Ok(state_content) = std::fs::read_to_string(&state_path) {
                            if let Ok(state) = serde_json::from_str::<serde_json::Value>(&state_content) {
                                if let Some(machine_states) = state.get("machine_states") {
                                    if let Some(machine_states_obj) = machine_states.as_object() {
                                        println!("      ğŸ“¡ Config Sync Status:");
                                        for (machine_id52, machine_state) in machine_states_obj {
                                            if let Some(machine_alias) = machine_state.get("machine_alias") {
                                                if let Some(sync_status) = machine_state.get("sync_status") {
                                                    if let Some(last_sync) = machine_state.get("last_sync") {
                                                        println!("         {} ({}): {} at {}", 
                                                               machine_alias.as_str().unwrap_or("unknown"),
                                                               &machine_id52[..8],
                                                               sync_status.as_str().unwrap_or("unknown"),
                                                               last_sync.as_str().unwrap_or("unknown"));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        println!("      âš ï¸  No sync status (state.json not found)");
                    }
                }
            }
            
            println!("\nğŸ–¥ï¸  Machine Configurations:");
            if configs.machine_configs.is_empty() {
                println!("   âŒ No machine roles");
            } else {
                for machine_config in &configs.machine_configs {
                    println!("   ğŸ–¥ï¸  {} ({})", machine_config.cluster_alias, machine_config.machine_role);
                    println!("      ğŸ“„ Config: {}", machine_config.config_path.display());
                }
            }
            
            println!("\nğŸ“¡ Services:");
            let services_path = malai_home.join("services.toml");
            if services_path.exists() {
                println!("   ğŸ“„ services.toml found");
                // TODO: Parse and show service configurations
            } else {
                println!("   âŒ No services.toml (no local service forwarding)");
            }
        }
        Err(e) => {
            println!("âŒ Configuration validation failed: {}", e);
        }
    }
    
    Ok(())
}

/// TEMPORARILY DISABLED - Start services based on validated configurations (ONE LISTENER PER IDENTITY) 
async fn start_services_from_configs(_configs: ValidatedConfigs) -> Result<()> {
    println!("âš ï¸ Service startup temporarily disabled - using simple_server.rs");
    Ok(())
}
