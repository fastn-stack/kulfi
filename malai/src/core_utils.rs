/// Simple SSH utilities for CLI commands
/// This module provides the basic functionality needed for SSH commands
/// without the complex fastn-p2p integration

use eyre::Result;
use std::path::PathBuf;
use std::str::FromStr;

/// Get MALAI_HOME directory with proper defaults
pub fn get_malai_home() -> PathBuf {
    if let Ok(malai_home) = std::env::var("MALAI_HOME") {
        PathBuf::from(malai_home)
    } else {
        get_default_malai_home()
    }
}

/// Get default MALAI_HOME directory based on platform
pub fn get_default_malai_home() -> PathBuf {
    if let Some(data_dir) = dirs::data_dir() {
        data_dir.join("malai")
    } else {
        // Fallback to current directory
        std::env::current_dir().unwrap_or_default().join(".malai")
    }
}

/// Initialize cluster with required cluster name
pub async fn init_cluster(cluster_name: String) -> Result<()> {
    println!("🏗️  Creating SSH cluster...");
    
    let malai_home = get_malai_home();
    let cluster_dir = malai_home.join("clusters").join(&cluster_name);
    
    // Ensure cluster directory exists
    std::fs::create_dir_all(&cluster_dir)?;
    
    // Generate or read existing cluster manager identity
    let identity_dir = malai_home.join("keys");
    std::fs::create_dir_all(&identity_dir)?;
    
    let identity_file = identity_dir.join("identity.key");
    let (cluster_manager_id52, cluster_manager_secret) = if identity_file.exists() {
        // Read existing identity
        let secret_key_hex = std::fs::read_to_string(&identity_file)?;
        let secret_key = fastn_id52::SecretKey::from_str(&secret_key_hex.trim())?;
        let id52 = secret_key.id52();
        (id52, secret_key)
    } else {
        // Generate new identity
        let (id52, secret_key) = { let secret_key = fastn_id52::SecretKey::generate(); (secret_key.id52(), secret_key) };
        // Save to file
        std::fs::write(&identity_file, secret_key.to_string())?;
        (id52, secret_key)
    };
    
    println!("📝 Generated cluster manager identity: {}", cluster_manager_id52);
    
    // Create basic cluster config  
    let cluster_config = format!(
        r#"# Malai SSH Cluster Configuration
# Generated by: malai ssh cluster init {}
# Cluster Name: {}
# Cluster Manager: {}

[cluster_manager]
id52 = "{}"
cluster_name = "{}"
use_keyring = true

# Add machines to this cluster by editing this file
# Examples:

# Basic machine (accepts SSH)
# [machine.web01]
# id52 = "machine-id52-here"
# accept_ssh = true
# allow_from = "*"

# With command aliases
# [machine.web01.command.restart-nginx]
# allow_from = "admins"
# command = "sudo systemctl restart nginx"

# With HTTP services  
# [machine.web01.http.admin]
# port = 8080
# allow_from = "admins"
# secure = false
"#,
        cluster_name,
        cluster_name,
        cluster_manager_id52,
        cluster_manager_id52,
        cluster_name
    );
    
    let config_path = cluster_dir.join("cluster-config.toml");
    std::fs::write(&config_path, cluster_config)?;
    
    println!("✅ Cluster configuration created at: {}", config_path.display());
    println!("Cluster created with ID: {}", cluster_manager_id52);
    println!("Cluster name: {}", cluster_name);
    
    Ok(())
}

/// Show cluster information
pub async fn show_cluster_info() -> Result<()> {
    println!("📋 Cluster Information:");
    
    let malai_home = get_malai_home();
    let config_path = malai_home.join("cluster-config.toml");
    
    if !config_path.exists() {
        println!("❌ No cluster configuration found at: {}", config_path.display());
        println!("💡 Create a cluster with: malai ssh create-cluster");
        return Ok(());
    }
    
    // Read config to determine role
    let config_content = std::fs::read_to_string(&config_path)?;
    println!("📄 Config path: {}", config_path.display());
    
    // Parse basic info (simple parsing, not full TOML)
    if let Some(manager_line) = config_content.lines().find(|l| l.starts_with("id52 = ") && !l.contains("[machine.")) {
        let cluster_id = manager_line
            .split('"')
            .nth(1)
            .unwrap_or("unknown");
        println!("🆔 Cluster ID: {}", cluster_id);
        
        // Check local identity to determine role
        let identity_file = malai_home.join("keys").join("identity.key");
        if identity_file.exists() {
            if let Ok(secret_key_hex) = std::fs::read_to_string(&identity_file) {
                if let Ok(secret_key) = fastn_id52::SecretKey::from_str(secret_key_hex.trim()) {
                    let local_id52 = secret_key.id52();
            
                    if local_id52 == cluster_id {
                        println!("👑 Role: cluster-manager");
                    } else if config_content.contains(&local_id52) {
                        // Find machine name
                        for line in config_content.lines() {
                            if line.contains(&local_id52) {
                                if let Some(machine_section) = config_content.lines().rev().find(|l| l.starts_with("[machine.") && config_content[config_content.find(l).unwrap()..].contains(&local_id52)) {
                                    let machine_name = machine_section
                                        .trim_start_matches("[machine.")
                                        .trim_end_matches("]");
                                    
                                    let machine_section_start = config_content.find(machine_section).unwrap();
                                    let machine_config = &config_content[machine_section_start..];
                                    if machine_config.split("[").next().unwrap().contains("accept_ssh = true") {
                                        println!("🖥️  Role: SSH server ({})", machine_name);
                                    } else {
                                        println!("💻 Role: client-only ({})", machine_name);
                                    }
                                    break;
                                }
                            }
                        }
                    } else {
                        println!("❓ Role: unknown (not found in cluster config)");
                    }
                }
            }
        }
    }
    
    Ok(())
}

/// Initialize machine for cluster with alias (new top-level API)  
pub async fn init_machine_for_cluster_with_alias(cluster_manager: String, cluster_alias: String) -> Result<()> {
    println!("🏗️  Initializing machine for cluster...");
    println!("🎯 Cluster: {} (alias: {})", cluster_manager, cluster_alias);
    
    let malai_home = get_malai_home();
    let identity_dir = malai_home.join("keys");
    std::fs::create_dir_all(&identity_dir)?;
    
    let identity_file = identity_dir.join("identity.key");
    
    if identity_file.exists() {
        println!("⚠️  Machine already initialized");
        let secret_key_hex = std::fs::read_to_string(&identity_file)?;
        let secret_key = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
        let machine_id52 = secret_key.id52();
        println!("🆔 Existing machine ID: {}", machine_id52);
        return Ok(());
    }
    
    // Generate new machine identity
    let (machine_id52, machine_secret) = { let secret_key = fastn_id52::SecretKey::generate(); (secret_key.id52(), secret_key) };
    std::fs::write(&identity_file, machine_secret.to_string())?;
    
    println!("📝 Generated machine identity: {}", machine_id52);
    
    // Contact cluster manager and create cluster-specific directory
    println!("🔗 Contacting cluster manager: {}", cluster_manager);
    match contact_cluster_manager(&cluster_manager, &machine_id52, &malai_home).await {
        Ok(cluster_manager_id52) => {
            // Create cluster-specific directory
            let cluster_dir = malai_home.join("clusters").join(&cluster_alias);
            std::fs::create_dir_all(&cluster_dir)?;
            
            // Save cluster info
            let cluster_info = format!(
                r#"# Cluster registration information
cluster_alias = "{}"
cluster_id52 = "{}"
machine_id52 = "{}"
"#,
                cluster_alias, cluster_manager_id52, machine_id52
            );
            
            std::fs::write(cluster_dir.join("cluster-info.toml"), cluster_info)?;
            
            println!("✅ Machine registered with cluster: {} (alias: {})", cluster_manager, cluster_alias);
            println!("Machine created with ID: {}", machine_id52);
            println!("📋 Next steps:");
            println!("1. Cluster admin will add your machine to cluster config");
            println!("2. Start services: malai start");
        }
        Err(e) => {
            println!("❌ Failed to contact cluster manager: {}", e);
            println!("Machine created with ID: {}", machine_id52);
            println!("📋 Manual steps required:");
            println!("1. Share machine ID with cluster administrator: {}", machine_id52);
            println!("2. Admin should add machine to cluster config");
        }
    }
    
    Ok(())
}

/// Legacy function - initialize machine for SSH cluster (generates identity, contacts cluster manager)
pub async fn init_machine_for_cluster(cluster: String) -> Result<()> {
    // Extract alias from cluster string or use a default
    let cluster_alias = if cluster.contains('.') {
        cluster.split('.').next().unwrap_or("default").to_string()
    } else {
        "default".to_string()
    };
    
    init_machine_for_cluster_with_alias(cluster, cluster_alias).await
}

/// Contact cluster manager to register machine and get cluster manager ID52
async fn contact_cluster_manager(cluster: &str, machine_id52: &str, malai_home: &PathBuf) -> Result<String> {
    println!("🔍 Resolving cluster manager for: {}", cluster);
    
    // Try to resolve cluster name (domain or direct ID52)
    let cluster_manager_id52 = if cluster.contains('.') {
        // Domain name - TODO: implement DNS TXT record lookup
        println!("🌐 Cluster appears to be domain name: {}", cluster);
        println!("💡 DNS TXT record lookup not yet implemented");
        return Err(eyre::eyre!("DNS resolution not yet implemented"));
    } else {
        // Assume it's a direct cluster manager ID52
        println!("🆔 Using cluster as direct cluster manager ID52");
        cluster.to_string()
    };
    
    // TODO: Contact cluster manager via P2P to register this machine
    println!("📡 Would contact cluster manager {} to register machine {}", cluster_manager_id52, machine_id52);
    
    todo!("Implement P2P registration with cluster manager");
}

/// Legacy function for backward compatibility
pub async fn create_cluster(alias: Option<String>) -> Result<()> {
    let cluster_name = alias.unwrap_or_else(|| "default".to_string());
    init_cluster(cluster_name).await
}

/// Legacy function for backward compatibility  
pub async fn init_machine() -> Result<()> {
    println!("❌ Machine init requires cluster name");
    println!("💡 Usage: malai ssh machine init <cluster-name-or-id52>");
    println!("💡 Example: malai ssh machine init company");
    Ok(())
}

/// Start malai daemon with lockfile and daemonization
pub async fn start_malai_daemon(environment: bool, foreground: bool) -> Result<()> {
    if environment {
        // Print environment variables for shell integration
        let malai_home = get_malai_home();
        println!("MALAI_HOME={}", malai_home.display());
        println!("MALAI_DAEMON_SOCK={}", malai_home.join("malai.sock").display());
        return Ok(());
    }
    
    let malai_home = get_malai_home();
    println!("🚀 Starting malai daemon...");
    println!("📁 MALAI_HOME: {}", malai_home.display());
    
    // Acquire exclusive lock (following fastn-rig pattern)
    let lock_path = malai_home.join("malai.lock");
    let lock_file = std::fs::OpenOptions::new()
        .create(true)
        .truncate(false)
        .write(true)
        .open(&lock_path)?;
    
    match lock_file.try_lock() {
        Ok(()) => {
            println!("🔒 Lock acquired: {}", lock_path.display());
        }
        Err(_) => {
            println!("❌ Another malai daemon already running at {}", malai_home.display());
            return Ok(());
        }
    }
    
    let _lock_guard = lock_file; // Hold lock for daemon lifetime
    
    // Daemonize unless in foreground mode
    if !foreground {
        println!("🔄 Daemonizing (use --foreground to stay in terminal)...");
        // TODO: Implement actual fork/daemonize  
        println!("📋 For now running in foreground (daemonization not yet implemented)");
    } else {
        println!("📋 Running in foreground mode");
    }
    
    // Scan and report configurations
    scan_and_report_configs(&malai_home).await?;
    
    println!("✅ malai daemon started");
    println!("💡 Use 'malai daemon -e' for environment variables");
    println!("📨 malai daemon running. Press Ctrl+C to stop.");
    
    // TODO: Start actual daemon services using fastn_p2p::spawn()
    
    // Wait for graceful shutdown using fastn-p2p global singleton
    fastn_p2p::cancelled().await;
    
    println!("👋 malai daemon stopped gracefully");
    Ok(())
}

/// Scan MALAI_HOME and report configurations  
async fn scan_and_report_configs(malai_home: &PathBuf) -> Result<()> {
    println!("🔍 Scanning for configurations...");
    
    let clusters_dir = malai_home.join("clusters");
    
    if !clusters_dir.exists() {
        println!("❌ No clusters directory found");
        println!("💡 Initialize a cluster: malai cluster init <name>");
        return Ok(());
    }
    
    println!("📂 Clusters directory: {}", clusters_dir.display());
    
    // Simple cluster count for now
    if let Ok(entries) = std::fs::read_dir(&clusters_dir) {
        let cluster_count = entries.filter(|entry| {
            entry.as_ref().map(|e| e.file_type().map(|t| t.is_dir()).unwrap_or(false)).unwrap_or(false)
        }).count();
        
        println!("📊 Found {} cluster directories", cluster_count);
    }
    
    Ok(())
}
