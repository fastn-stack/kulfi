/// Simple SSH utilities for CLI commands
/// This module provides the basic functionality needed for SSH commands
/// without the complex fastn-p2p integration

use eyre::Result;
use std::path::PathBuf;
use std::str::FromStr;

/// Get MALAI_HOME directory with proper defaults
pub fn get_malai_home() -> PathBuf {
    if let Ok(malai_home) = std::env::var("MALAI_HOME") {
        PathBuf::from(malai_home)
    } else {
        get_default_malai_home()
    }
}

/// Get default MALAI_HOME directory based on platform
pub fn get_default_malai_home() -> PathBuf {
    if let Some(data_dir) = dirs::data_dir() {
        data_dir.join("malai")
    } else {
        // Fallback to current directory
        std::env::current_dir().unwrap_or_default().join(".malai")
    }
}

/// Initialize cluster with required cluster name
pub async fn init_cluster(cluster_name: String) -> Result<()> {
    println!("ğŸ—ï¸  Creating SSH cluster...");
    
    let malai_home = get_malai_home();
    let ssh_dir = malai_home.clone();
    
    // Ensure SSH directory exists
    std::fs::create_dir_all(&ssh_dir)?;
    
    // Generate or read existing cluster manager identity
    let identity_dir = malai_home.join("keys");
    std::fs::create_dir_all(&identity_dir)?;
    
    let identity_file = identity_dir.join("identity.key");
    let (cluster_manager_id52, cluster_manager_secret) = if identity_file.exists() {
        // Read existing identity
        let secret_key_hex = std::fs::read_to_string(&identity_file)?;
        let secret_key = fastn_id52::SecretKey::from_str(&secret_key_hex.trim())?;
        let id52 = secret_key.id52();
        (id52, secret_key)
    } else {
        // Generate new identity
        let (id52, secret_key) = { let secret_key = fastn_id52::SecretKey::generate(); (secret_key.id52(), secret_key) };
        // Save to file
        std::fs::write(&identity_file, secret_key.to_string())?;
        (id52, secret_key)
    };
    
    println!("ğŸ“ Generated cluster manager identity: {}", cluster_manager_id52);
    
    // Create basic cluster config  
    let cluster_config = format!(
        r#"# Malai SSH Cluster Configuration
# Generated by: malai ssh cluster init {}
# Cluster Name: {}
# Cluster Manager: {}

[cluster_manager]
id52 = "{}"
cluster_name = "{}"
use_keyring = true

# Add machines to this cluster by editing this file
# Examples:

# Basic machine (accepts SSH)
# [machine.web01]
# id52 = "machine-id52-here"
# accept_ssh = true
# allow_from = "*"

# With command aliases
# [machine.web01.command.restart-nginx]
# allow_from = "admins"
# command = "sudo systemctl restart nginx"

# With HTTP services  
# [machine.web01.http.admin]
# port = 8080
# allow_from = "admins"
# secure = false
"#,
        cluster_name,
        cluster_name,
        cluster_manager_id52,
        cluster_manager_id52,
        cluster_name
    );
    
    let config_path = ssh_dir.join("cluster-config.toml");
    std::fs::write(&config_path, cluster_config)?;
    
    println!("âœ… Cluster configuration created at: {}", config_path.display());
    println!("Cluster created with ID: {}", cluster_manager_id52);
    println!("Cluster name: {}", cluster_name);
    
    Ok(())
}

/// Show cluster information
pub async fn show_cluster_info() -> Result<()> {
    println!("ğŸ“‹ Cluster Information:");
    
    let malai_home = get_malai_home();
    let config_path = malai_home.join("cluster-config.toml");
    
    if !config_path.exists() {
        println!("âŒ No cluster configuration found at: {}", config_path.display());
        println!("ğŸ’¡ Create a cluster with: malai ssh create-cluster");
        return Ok(());
    }
    
    // Read config to determine role
    let config_content = std::fs::read_to_string(&config_path)?;
    println!("ğŸ“„ Config path: {}", config_path.display());
    
    // Parse basic info (simple parsing, not full TOML)
    if let Some(manager_line) = config_content.lines().find(|l| l.starts_with("id52 = ") && !l.contains("[machine.")) {
        let cluster_id = manager_line
            .split('"')
            .nth(1)
            .unwrap_or("unknown");
        println!("ğŸ†” Cluster ID: {}", cluster_id);
        
        // Check local identity to determine role
        let identity_file = malai_home.join("keys").join("identity.key");
        if identity_file.exists() {
            if let Ok(secret_key_hex) = std::fs::read_to_string(&identity_file) {
                if let Ok(secret_key) = fastn_id52::SecretKey::from_str(secret_key_hex.trim()) {
                    let local_id52 = secret_key.id52();
            
                    if local_id52 == cluster_id {
                        println!("ğŸ‘‘ Role: cluster-manager");
                    } else if config_content.contains(&local_id52) {
                        // Find machine name
                        for line in config_content.lines() {
                            if line.contains(&local_id52) {
                                if let Some(machine_section) = config_content.lines().rev().find(|l| l.starts_with("[machine.") && config_content[config_content.find(l).unwrap()..].contains(&local_id52)) {
                                    let machine_name = machine_section
                                        .trim_start_matches("[machine.")
                                        .trim_end_matches("]");
                                    
                                    let machine_section_start = config_content.find(machine_section).unwrap();
                                    let machine_config = &config_content[machine_section_start..];
                                    if machine_config.split("[").next().unwrap().contains("accept_ssh = true") {
                                        println!("ğŸ–¥ï¸  Role: SSH server ({})", machine_name);
                                    } else {
                                        println!("ğŸ’» Role: client-only ({})", machine_name);
                                    }
                                    break;
                                }
                            }
                        }
                    } else {
                        println!("â“ Role: unknown (not found in cluster config)");
                    }
                }
            }
        }
    }
    
    Ok(())
}

/// Initialize machine for cluster with alias (new top-level API)  
pub async fn init_machine_for_cluster_with_alias(cluster_manager: String, cluster_alias: String) -> Result<()> {
    println!("ğŸ—ï¸  Initializing machine for cluster...");
    println!("ğŸ¯ Cluster: {} (alias: {})", cluster_manager, cluster_alias);
    
    let malai_home = get_malai_home();
    let identity_dir = malai_home.join("keys");
    std::fs::create_dir_all(&identity_dir)?;
    
    let identity_file = identity_dir.join("identity.key");
    
    if identity_file.exists() {
        println!("âš ï¸  Machine already initialized");
        let secret_key_hex = std::fs::read_to_string(&identity_file)?;
        let secret_key = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
        let machine_id52 = secret_key.id52();
        println!("ğŸ†” Existing machine ID: {}", machine_id52);
        return Ok(());
    }
    
    // Generate new machine identity
    let (machine_id52, machine_secret) = { let secret_key = fastn_id52::SecretKey::generate(); (secret_key.id52(), secret_key) };
    std::fs::write(&identity_file, machine_secret.to_string())?;
    
    println!("ğŸ“ Generated machine identity: {}", machine_id52);
    
    // Contact cluster manager and create cluster-specific directory
    println!("ğŸ”— Contacting cluster manager: {}", cluster_manager);
    match contact_cluster_manager(&cluster_manager, &machine_id52, &malai_home).await {
        Ok(cluster_manager_id52) => {
            // Create cluster-specific directory
            let cluster_dir = malai_home.join("clusters").join(&cluster_alias);
            std::fs::create_dir_all(&cluster_dir)?;
            
            // Save cluster info
            let cluster_info = format!(
                r#"# Cluster registration information
cluster_alias = "{}"
cluster_id52 = "{}"
machine_id52 = "{}"
"#,
                cluster_alias, cluster_manager_id52, machine_id52
            );
            
            std::fs::write(cluster_dir.join("cluster-info.toml"), cluster_info)?;
            
            println!("âœ… Machine registered with cluster: {} (alias: {})", cluster_manager, cluster_alias);
            println!("Machine created with ID: {}", machine_id52);
            println!("ğŸ“‹ Next steps:");
            println!("1. Cluster admin will add your machine to cluster config");
            println!("2. Start services: malai start");
        }
        Err(e) => {
            println!("âŒ Failed to contact cluster manager: {}", e);
            println!("Machine created with ID: {}", machine_id52);
            println!("ğŸ“‹ Manual steps required:");
            println!("1. Share machine ID with cluster administrator: {}", machine_id52);
            println!("2. Admin should add machine to cluster config");
        }
    }
    
    Ok(())
}

/// Legacy function - initialize machine for SSH cluster (generates identity, contacts cluster manager)
pub async fn init_machine_for_cluster(cluster: String) -> Result<()> {
    // Extract alias from cluster string or use a default
    let cluster_alias = if cluster.contains('.') {
        cluster.split('.').next().unwrap_or("default").to_string()
    } else {
        "default".to_string()
    };
    
    init_machine_for_cluster_with_alias(cluster, cluster_alias).await
}

/// Contact cluster manager to register machine and get cluster manager ID52
async fn contact_cluster_manager(cluster: &str, machine_id52: &str, malai_home: &PathBuf) -> Result<String> {
    println!("ğŸ” Resolving cluster manager for: {}", cluster);
    
    // Try to resolve cluster name (domain or direct ID52)
    let cluster_manager_id52 = if cluster.contains('.') {
        // Domain name - TODO: implement DNS TXT record lookup
        println!("ğŸŒ Cluster appears to be domain name: {}", cluster);
        println!("ğŸ’¡ DNS TXT record lookup not yet implemented");
        return Err(eyre::eyre!("DNS resolution not yet implemented"));
    } else {
        // Assume it's a direct cluster manager ID52
        println!("ğŸ†” Using cluster as direct cluster manager ID52");
        cluster.to_string()
    };
    
    // TODO: Contact cluster manager via P2P to register this machine
    println!("ğŸ“¡ Would contact cluster manager {} to register machine {}", cluster_manager_id52, machine_id52);
    
    todo!("Implement P2P registration with cluster manager");
}

/// Legacy function for backward compatibility
pub async fn create_cluster(alias: Option<String>) -> Result<()> {
    let cluster_name = alias.unwrap_or_else(|| "default".to_string());
    init_cluster(cluster_name).await
}

/// Legacy function for backward compatibility  
pub async fn init_machine() -> Result<()> {
    println!("âŒ Machine init requires cluster name");
    println!("ğŸ’¡ Usage: malai ssh machine init <cluster-name-or-id52>");
    println!("ğŸ’¡ Example: malai ssh machine init company");
    Ok(())
}

/// Start malai daemon with lockfile and daemonization
pub async fn start_malai_daemon(environment: bool, foreground: bool) -> Result<()> {
    if environment {
        // Print environment variables for shell integration
        let malai_home = get_malai_home();
        println!("MALAI_HOME={}", malai_home.display());
        println!("MALAI_DAEMON_SOCK={}", malai_home.join("malai.sock").display());
        return Ok(());
    }
    
    let malai_home = get_malai_home();
    println!("ğŸš€ Starting malai daemon...");
    println!("ğŸ“ MALAI_HOME: {}", malai_home.display());
    
    // Check for existing daemon
    if check_existing_daemon(&malai_home)? {
        println!("âœ… malai daemon already running");
        return Ok(());
    }
    
    // Create lockfile
    create_daemon_lockfile(&malai_home)?;
    
    // Daemonize unless in foreground mode
    if !foreground {
        println!("ğŸ”„ Daemonizing (use --foreground to stay in terminal)...");
        // TODO: Implement actual fork/daemonize  
        println!("ğŸ“‹ For now running in foreground (daemonization not yet implemented)");
    } else {
        println!("ğŸ“‹ Running in foreground mode");
    }
    
    // Scan and report configurations
    scan_and_report_configs(&malai_home).await?;
    
    println!("âœ… malai daemon started");
    println!("ğŸ’¡ Use 'malai daemon -e' for environment variables");
    
    // Keep daemon running
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    }
}

/// Check if malai daemon is already running using file locking
fn check_existing_daemon(malai_home: &PathBuf) -> Result<bool> {
    let lockfile_path = malai_home.join("malai.lock");
    
    if !lockfile_path.exists() {
        return Ok(false);
    }
    
    // Try to acquire lock on existing file
    match std::fs::OpenOptions::new()
        .create(false)
        .write(true)
        .open(&lockfile_path)
    {
        Ok(lock_file) => {
            match lock_file.try_lock() {
                Ok(()) => {
                    // We got the lock, so daemon is not running
                    println!("ğŸ—‘ï¸  Removing stale lockfile (no running daemon)");
                    let _ = std::fs::remove_file(&lockfile_path);
                    Ok(false)
                }
                Err(_) => {
                    // Could not acquire lock, daemon is running
                    println!("âœ… Daemon already running");
                    Ok(true)
                }
            }
        }
        Err(_) => {
            // Could not open file, assume no daemon
            Ok(false)
        }
    }
}

/// Create daemon lockfile with exclusive locking
fn create_daemon_lockfile(malai_home: &PathBuf) -> Result<()> {
    let lockfile_path = malai_home.join("malai.lock");
    
    // Create and lock the file
    let lock_file = std::fs::OpenOptions::new()
        .create(true)
        .truncate(true)
        .write(true)
        .open(&lockfile_path)?;
    
    // Try to acquire exclusive lock
    lock_file.try_lock().map_err(|_| {
        eyre::eyre!("Could not acquire daemon lock - another instance may be running")
    })?;
    
    println!("ğŸ” Created daemon lockfile with exclusive lock");
    
    // Keep lock alive for daemon lifetime
    std::mem::forget(lock_file); // Lock released when process ends
    Ok(())
}

/// Scan MALAI_HOME and report what configs we find
async fn scan_and_report_configs(malai_home: &PathBuf) -> Result<()> {
    println!("ğŸ” Scanning for configurations...");
    
    let clusters_dir = malai_home.join("clusters");
    
    if !clusters_dir.exists() {
        println!("âŒ No clusters directory found: {}", clusters_dir.display());
        println!("ğŸ’¡ Initialize a cluster: malai cluster init <name>");
        return Ok(());
    }
    
    println!("ğŸ“‚ Clusters directory: {}", clusters_dir.display());
    
    // Scan cluster directories
    if let Ok(entries) = std::fs::read_dir(&clusters_dir) {
        let mut found_clusters = false;
        
        for entry in entries.flatten() {
            if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {
                found_clusters = true;
                let cluster_alias = entry.file_name().to_string_lossy().to_string();
                let cluster_dir = entry.path();
                
                println!("\nğŸ“‹ Cluster: {}", cluster_alias);
                println!("   ğŸ“ Directory: {}", cluster_dir.display());
                
                // Check what files exist
                let config_path = cluster_dir.join("cluster-config.toml");
                let machine_config_path = cluster_dir.join("machine-config.toml");
                let cluster_info_path = cluster_dir.join("cluster-info.toml");
                let identity_path = cluster_dir.join("identity.key");
                let state_path = cluster_dir.join("state.json");
                
                if config_path.exists() {
                    println!("   ğŸ‘‘ cluster-config.toml found â†’ CLUSTER MANAGER");
                    if let Ok(content) = std::fs::read_to_string(&config_path) {
                        let hash = calculate_config_hash(&content);
                        println!("   ğŸ“„ Config hash: {}", hash);
                        
                        // Count machines in config
                        let machine_count = content.lines()
                            .filter(|line| line.trim().starts_with("[machine.") && !line.trim().starts_with('#'))
                            .count();
                        println!("   ğŸ“Š Machines in cluster: {}", machine_count);
                    }
                    
                    // Check if we have state.json
                    if state_path.exists() {
                        println!("   ğŸ“Š state.json found â†’ Ready for config distribution");
                    } else {
                        println!("   ğŸ†• Will create state.json for config tracking");
                    }
                } else {
                    println!("   âŒ No cluster-config.toml");
                }
                
                if machine_config_path.exists() {
                    println!("   ğŸ–¥ï¸  machine-config.toml found â†’ SSH DAEMON");
                    // TODO: Parse machine config to check SSH permissions
                } else if cluster_info_path.exists() {
                    println!("   ğŸ“‹ cluster-info.toml found â†’ Machine registered, waiting for config");
                } else {
                    println!("   ğŸ’» CLIENT-ONLY (no machine role in cluster)");
                }
                
                // Show identity and registration details
                if identity_path.exists() {
                    println!("   ğŸ”‘ identity.key found");
                } else {
                    println!("   âŒ No identity.key");
                }
                
                if cluster_info_path.exists() && !machine_config_path.exists() {
                    // Show registration details for machines waiting for config
                    if let Ok(content) = std::fs::read_to_string(&cluster_info_path) {
                        for line in content.lines().take(3) {
                            if !line.starts_with('#') && !line.trim().is_empty() {
                                println!("      ğŸ“ {}", line.trim());
                            }
                        }
                    }
                }
            }
        }
        
        if !found_clusters {
            println!("âŒ No cluster directories found in {}", clusters_dir.display());
            println!("ğŸ’¡ Initialize a cluster: malai cluster init <name>");
        }
    } else {
        println!("âŒ Could not read clusters directory");
    }
    
    Ok(())
}

/// Legacy function - start SSH cluster manager
pub async fn start_ssh_cluster(environment: bool) -> Result<()> {
    if environment {
        // Print environment variables for shell integration
        let malai_home = get_malai_home();
        let cluster_sock = malai_home.join("cluster.sock");
        println!("MALAI_SSH_CLUSTER={}", cluster_sock.display());
        return Ok(());
    }
    
    println!("ğŸ‘‘ Starting SSH cluster manager...");
    let malai_home = get_malai_home();
    
    // Check that this is actually a cluster manager
    let config_path = malai_home.join("cluster-config.toml");
    if !config_path.exists() {
        println!("âŒ No cluster config found");
        println!("ğŸ’¡ Initialize cluster first: malai ssh cluster init");
        return Ok(());
    }
    
    // Verify this machine is the cluster manager
    let role = detect_machine_role(&malai_home).await?;
    if !matches!(role, MachineRole::ClusterManager) {
        println!("âŒ This machine is not the cluster manager");
        println!("ğŸ’¡ Cluster manager must be run on the machine that initialized the cluster");
        return Ok(());
    }
    
    // Start cluster manager services
    start_cluster_manager_services(&malai_home).await?;
    
    println!("âœ… SSH cluster manager started successfully");
    println!("ğŸ’¡ Use 'malai ssh cluster start -e' for environment variables");
    
    // Keep cluster manager running
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
    }
}

/// Execute SSH command on remote machine
pub async fn execute_ssh_command(machine_address: &str, command: &str, args: Vec<String>) -> Result<()> {
    println!("ğŸ§ª Executing SSH command...");
    println!("ğŸ“ Target: {}", machine_address);
    println!("ğŸ’» Command: {} {:?}", command, args);
    
    let malai_home = get_malai_home();
    
    // Check if we have local identity
    let identity_file = malai_home.join("keys").join("identity.key");
    if !identity_file.exists() {
        println!("âŒ No machine identity found");
        println!("ğŸ’¡ Run 'malai ssh init' to initialize this machine");
        return Ok(());
    }
    
    // Check if we have cluster config
    let config_path = malai_home.join("cluster-config.toml");
    if !config_path.exists() {
        println!("âŒ No cluster configuration found");
        println!("ğŸ’¡ Options:");
        println!("   - Initialize cluster: malai ssh init-cluster");
        println!("   - Wait for config from cluster manager");
        return Ok(());
    }
    
    // Parse target machine from address
    let target_machine = parse_machine_address(machine_address)?;
    println!("ğŸ¯ Parsed target: {}", target_machine);
    
    // Check permissions and resolve command
    let resolved_command = resolve_command_permissions(&malai_home, &target_machine, command).await?;
    
    match resolved_command {
        Some(actual_command) => {
            println!("âœ… Permission granted");
            println!("ğŸ”§ Resolved command: {}", actual_command);
            
            // Execute via P2P communication
            println!("ğŸ“¡ Executing via P2P: '{}'", actual_command);
            println!("ğŸ¯ Target machine: {}", target_machine);
            
            match execute_command_via_p2p(&malai_home, &target_machine, &actual_command, &args).await {
                Ok(output) => {
                    // Print command output
                    if !output.stdout.is_empty() {
                        print!("{}", String::from_utf8_lossy(&output.stdout));
                    }
                    if !output.stderr.is_empty() {
                        eprint!("{}", String::from_utf8_lossy(&output.stderr));
                    }
                    
                    if output.exit_code == 0 {
                        println!("âœ… SSH command executed successfully");
                    } else {
                        println!("âŒ SSH command failed with exit code: {}", output.exit_code);
                    }
                }
                Err(e) => {
                    println!("âŒ P2P execution failed: {}", e);
                    println!("ğŸ’¡ Check that target machine agent is running");
                }
            }
        }
        None => {
            println!("âŒ Permission denied");
            println!("ğŸ’¡ Contact cluster administrator to add access permissions");
        }
    }
    
    Ok(())
}

/// Parse machine address (web01.cluster-name, web01.cluster-id52, etc.)
fn parse_machine_address(address: &str) -> Result<String> {
    if let Some(machine_part) = address.split('.').next() {
        Ok(machine_part.to_string())
    } else {
        Ok(address.to_string())
    }
}

/// Check permissions and resolve command aliases
async fn resolve_command_permissions(malai_home: &PathBuf, target_machine: &str, command: &str) -> Result<Option<String>> {
    let config_path = malai_home.join("cluster-config.toml");
    let config_content = std::fs::read_to_string(&config_path)?;
    
    // Get local identity
    let identity_file = malai_home.join("keys").join("identity.key");
    let secret_key_hex = std::fs::read_to_string(&identity_file)?;
    let secret_key = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
    let local_id52 = secret_key.id52();
    
    println!("ğŸ” Checking permissions...");
    println!("   Client ID: {}", local_id52);
    println!("   Target machine: {}", target_machine);
    println!("   Command: {}", command);
    
    // Look for command alias first
    let command_alias_section = format!("[machine.{}.command.{}]", target_machine, command);
    if let Some(alias_section_start) = config_content.find(&command_alias_section) {
        println!("ğŸ” Found command alias section: {}", command_alias_section);
        
        // Extract the alias section content
        let remaining = &config_content[alias_section_start..];
        let alias_section = remaining.split("[").next().unwrap_or("");
        
        // Check allow_from for this specific command
        if let Some(allow_line) = alias_section.lines().find(|l| l.trim().starts_with("allow_from")) {
            let allowed = allow_line.split('=').nth(1).unwrap_or("").trim().trim_matches('"');
            if check_access_permission(&config_content, &local_id52, allowed) {
                // Get the actual command to execute
                if let Some(command_line) = alias_section.lines().find(|l| l.trim().starts_with("command")) {
                    let actual_command = command_line.split('=').nth(1).unwrap_or("").trim().trim_matches('"');
                    return Ok(Some(actual_command.to_string()));
                } else {
                    // No command specified, use alias name
                    return Ok(Some(command.to_string()));
                }
            } else {
                println!("âŒ Access denied for command alias: {}", command);
                return Ok(None);
            }
        }
    }
    
    // Check general machine access - find REAL (uncommented) machine section
    let machine_section_pattern = format!("[machine.{}]", target_machine);
    println!("ğŸ” Looking for section: {}", machine_section_pattern);
    
    // Find all occurrences and check which one is not commented
    let mut start_pos = 0;
    while let Some(found_pos) = config_content[start_pos..].find(&machine_section_pattern) {
        let absolute_pos = start_pos + found_pos;
        
        // Check if this line is commented out
        let line_start = config_content[..absolute_pos].rfind('\n').map(|pos| pos + 1).unwrap_or(0);
        let line = &config_content[line_start..absolute_pos + machine_section_pattern.len()];
        
        if !line.trim_start().starts_with('#') {
            println!("âœ… Found uncommented machine section at position {}", absolute_pos);
            
            let remaining = &config_content[absolute_pos..];
            // Find the end of this section (next [ or end of file)
            let section_end = remaining.find("\n[").unwrap_or(remaining.len());
            let machine_section = &remaining[..section_end];
            println!("ğŸ” Machine section content:\n{}", machine_section);
            
            if let Some(allow_line) = machine_section.lines().find(|l| l.trim().starts_with("allow_from") && !l.trim().starts_with('#')) {
                println!("âœ… Found allow_from line: {}", allow_line.trim());
                let allowed = allow_line.split('=').nth(1).unwrap_or("").trim().trim_matches('"');
                if check_access_permission(&config_content, &local_id52, allowed) {
                    println!("âœ… General machine access granted");
                    return Ok(Some(command.to_string())); // Use command as-is
                } else {
                    println!("âŒ General machine access denied");
                    return Ok(None);
                }
            } else {
                println!("ğŸ” No allow_from line found in uncommented machine section");
                println!("ğŸ” Section lines: {:?}", machine_section.lines().collect::<Vec<_>>());
            }
            break;
        }
        
        start_pos = absolute_pos + 1; // Continue searching after this match
    }
    
    println!("âŒ Target machine '{}' not found in cluster config", target_machine);
    Ok(None)
}

/// Check if local machine has access based on allow_from field
fn check_access_permission(config_content: &str, local_id52: &str, allow_from: &str) -> bool {
    println!("ğŸ” Checking access: local_id52={}, allow_from='{}'", local_id52, allow_from);
    
    // Handle wildcard
    if allow_from == "*" {
        println!("âœ… Wildcard access granted");
        return true;
    }
    
    // Split allow_from and check each entry
    for entry in allow_from.split(',') {
        let entry = entry.trim();
        
        // Direct ID match
        if entry == local_id52 {
            println!("âœ… Direct ID match: {}", entry);
            return true;
        }
        
        // Group match (TODO: implement group expansion)
        if expand_group_membership(config_content, entry, local_id52) {
            println!("âœ… Group membership match: {}", entry);
            return true;
        }
    }
    
    println!("âŒ No access permission found");
    false
}

/// Check if local machine is member of group (recursive)
fn expand_group_membership(config_content: &str, group_name: &str, local_id52: &str) -> bool {
    let group_section = format!("[group.{}]", group_name);
    if let Some(group_start) = config_content.find(&group_section) {
        let remaining = &config_content[group_start..];
        let group_section = remaining.split("[").next().unwrap_or("");
        
        if let Some(members_line) = group_section.lines().find(|l| l.trim().starts_with("members")) {
            let members = members_line.split('=').nth(1).unwrap_or("").trim().trim_matches('"');
            
            for member in members.split(',') {
                let member = member.trim();
                
                // Direct ID match
                if member == local_id52 {
                    return true;
                }
                
                // Recursive group check
                if expand_group_membership(config_content, member, local_id52) {
                    return true;
                }
            }
        }
    }
    false
}

/// Execute command on remote machine via P2P
async fn execute_command_via_p2p(
    malai_home: &PathBuf, 
    target_machine: &str, 
    command: &str, 
    args: &[String]
) -> Result<CommandOutput> {
    // Get local identity for P2P communication
    let identity_file = malai_home.join("keys").join("identity.key");
    let secret_key_hex = std::fs::read_to_string(&identity_file)?;
    let local_secret = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
    
    // Get target machine's ID52 from config
    let config_path = malai_home.join("cluster-config.toml");
    let config_content = std::fs::read_to_string(&config_path)?;
    
    let target_id52 = find_machine_id52(&config_content, target_machine)?;
    println!("ğŸ”— Connecting to machine {} ({})", target_machine, target_id52);
    
    // Execute command via P2P
    todo!("Implement real P2P SSH execution - local simulation removed")
}

/// Find machine ID52 in config (find uncommented section)
fn find_machine_id52(config_content: &str, machine_name: &str) -> Result<String> {
    let machine_section_pattern = format!("[machine.{}]", machine_name);
    println!("ğŸ” Looking for machine ID52 in section: {}", machine_section_pattern);
    
    // Find all occurrences and check which one is not commented
    let mut start_pos = 0;
    while let Some(found_pos) = config_content[start_pos..].find(&machine_section_pattern) {
        let absolute_pos = start_pos + found_pos;
        
        // Check if this line is commented out
        let line_start = config_content[..absolute_pos].rfind('\n').map(|pos| pos + 1).unwrap_or(0);
        let line = &config_content[line_start..absolute_pos + machine_section_pattern.len()];
        
        if !line.trim_start().starts_with('#') {
            println!("âœ… Found uncommented machine section for ID52 lookup");
            
            let remaining = &config_content[absolute_pos..];
            let section_end = remaining.find("\n[").unwrap_or(remaining.len());
            let machine_section = &remaining[..section_end];
            
            println!("ğŸ” Machine section for ID52 lookup:\n{}", machine_section);
            
            if let Some(id52_line) = machine_section.lines().find(|l| l.trim().starts_with("id52") && !l.trim().starts_with('#')) {
                let id52 = id52_line.split('=').nth(1).unwrap_or("").trim().trim_matches('"');
                println!("âœ… Found machine ID52: {}", id52);
                return Ok(id52.to_string());
            } else {
                println!("âŒ No id52 line found in uncommented section");
            }
            break;
        }
        
        start_pos = absolute_pos + 1;
    }
    
    Err(eyre::eyre!("Machine '{}' ID52 not found in config", machine_name))
}

/// SSH protocol for P2P communication
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
enum SshProtocol {
    Execute,
    ConfigSync,
}

impl std::fmt::Display for SshProtocol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SshProtocol::Execute => write!(f, "ssh-execute"),
            SshProtocol::ConfigSync => write!(f, "ssh-config-sync"),
        }
    }
}

/// SSH execute request
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct SshExecuteRequest {
    client_id52: String,
    command: String,
    args: Vec<String>,
    env: Vec<(String, String)>,
    working_dir: Option<String>,
}

/// SSH execute response
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct SshExecuteResponse {
    stdout: Vec<u8>,
    stderr: Vec<u8>,
    exit_code: i32,
}

/// SSH execute error
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct SshExecuteError {
    message: String,
}

impl std::fmt::Display for SshExecuteError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

/// Config sync request
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct ConfigSyncRequest {
    config_content: String,
    sender_id52: String,
}

/// Config sync response
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct ConfigSyncResponse {
    success: bool,
    message: String,
}

/// Config sync error
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct ConfigSyncError {
    message: String,
}

impl std::fmt::Display for ConfigSyncError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

/// Command output structure
struct CommandOutput {
    stdout: Vec<u8>,
    stderr: Vec<u8>, 
    exit_code: i32,
}


/// Start SSH agent with role detection
pub async fn start_ssh_agent(environment: bool, lockdown: bool, http: bool) -> Result<()> {
    let malai_home = get_malai_home();
    
    if environment {
        // Print environment variables for shell integration
        let agent_sock = malai_home.join("agent.sock");
        
        println!("MALAI_SSH_AGENT={}", agent_sock.display());
        
        if lockdown {
            println!("MALAI_LOCKDOWN_MODE=true");
        }
        
        if http {
            println!("HTTP_PROXY=http://127.0.0.1:8080");  // Placeholder port
        }
        
        return Ok(());
    }
    
    println!("ğŸš€ Starting SSH agent...");
    println!("ğŸ“ Using MALAI_HOME: {}", malai_home.display());
    
    // Check for existing agent (lockfile protection)
    let lockfile = malai_home.join("agent.lock");
    if lockfile.exists() {
        println!("ğŸ”’ Agent lockfile exists, checking if agent is running...");
        
        if let Ok(pid_str) = std::fs::read_to_string(&lockfile) {
            if let Ok(pid) = pid_str.trim().parse::<u32>() {
                // if is_process_running(pid) {
                    println!("âœ… SSH agent already running (PID: {})", pid);
                    println!("ğŸ’¡ Use 'malai ssh agent -e' to get environment variables");
                    return Ok(());
                } else {
                    println!("ğŸ—‘ï¸  Removing stale lockfile (process {} not running)", pid);
                    let _ = std::fs::remove_file(&lockfile);
                }
            }
        }
    }
    
    // Create lockfile
    let agent_pid = std::process::id();
    std::fs::create_dir_all(lockfile.parent().unwrap())?;
    std::fs::write(&lockfile, agent_pid.to_string())?;
    println!("ğŸ” Created agent lockfile (PID: {})", agent_pid);
    
    // Detect role from cluster config
    let role = detect_machine_role(&malai_home).await?;
    
    match role {
        MachineRole::ClusterManager => {
            println!("ğŸ‘‘ Role detected: Cluster Manager");
            start_cluster_manager_services(&malai_home).await?;
        }
        MachineRole::SshServer(machine_name) => {
            println!("ğŸ–¥ï¸  Role detected: SSH Server ({})", machine_name);
            start_ssh_server_services(&malai_home, &machine_name).await?;
        }
        MachineRole::ClientOnly(machine_name) => {
            println!("ğŸ’» Role detected: Client Only ({})", machine_name);
            start_client_services(&malai_home, &machine_name).await?;
        }
        MachineRole::Unknown => {
            println!("â“ Role: Unknown - no cluster config found or identity not in config");
            println!("ğŸ’¡ Options:");
            println!("   - Create a cluster: malai ssh init-cluster");
            println!("   - Initialize machine: malai ssh init");
            println!("   - Wait for config from cluster manager (if machine already added to cluster)");
            
            // For machines without config, start config listener
            println!("ğŸ”§ Starting config listener (waiting for config from cluster manager...)");
            tokio::spawn(run_config_listener(malai_home.clone()));
            
            return Ok(());
        }
    }
    
    println!("âœ… SSH agent started successfully");
    println!("ğŸ’¡ Use 'malai ssh agent -e' to get environment variables for shell integration");
    
    // Keep agent running (in real implementation, this would be an event loop)
    println!("ğŸ”„ Agent running... (press Ctrl+C to stop)");
    
    // Cleanup lockfile on exit
    let lockfile_cleanup = lockfile.clone();
    tokio::spawn(async move {
        tokio::signal::ctrl_c().await.ok();
        let _ = std::fs::remove_file(lockfile_cleanup);
        println!("\nğŸ›‘ SSH agent stopped");
        std::process::exit(0);
    });
    
    // Simple keep-alive loop
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        // In real implementation, this would handle P2P connections and requests
    }
}

/// Detect machine role from cluster config and local identity
async fn detect_machine_role(malai_home: &PathBuf) -> Result<MachineRole> {
    let config_path = malai_home.join("cluster-config.toml");
    
    if !config_path.exists() {
        return Ok(MachineRole::Unknown);
    }
    
    let config_content = std::fs::read_to_string(&config_path)?;
    let identity_file = malai_home.join("keys").join("identity.key");
    
    if !identity_file.exists() {
        return Ok(MachineRole::Unknown);
    }
    
    let secret_key_hex = std::fs::read_to_string(&identity_file)?;
    let secret_key = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
    let local_id52 = secret_key.id52();
    
    // Parse cluster manager ID
    if let Some(manager_line) = config_content.lines().find(|l| l.starts_with("id52 = ") && !l.contains("[machine.")) {
        let cluster_id = manager_line
            .split('"')
            .nth(1)
            .unwrap_or("");
        
        if local_id52 == cluster_id {
            return Ok(MachineRole::ClusterManager);
        }
    }
    
    // Check if this machine is defined in config
    if config_content.contains(&local_id52) {
        // Find machine name and check accept_ssh
        for line in config_content.lines() {
            if line.starts_with("[machine.") && config_content[config_content.find(line).unwrap()..].contains(&local_id52) {
                let machine_name = line
                    .trim_start_matches("[machine.")
                    .trim_end_matches("]");
                
                // Check if this machine accepts SSH connections
                let machine_section_start = config_content.find(line).unwrap();
                let remaining_config = &config_content[machine_section_start..];
                let machine_section = remaining_config.split("[").next().unwrap();
                
                if machine_section.contains("accept_ssh = true") {
                    return Ok(MachineRole::SshServer(machine_name.to_string()));
                } else {
                    return Ok(MachineRole::ClientOnly(machine_name.to_string()));
                }
            }
        }
    }
    
    Ok(MachineRole::Unknown)
}

/// Detect roles across all clusters in MALAI_HOME
async fn detect_all_cluster_roles(malai_home: &PathBuf) -> Result<Vec<(String, MachineRole)>> {
    let mut roles = Vec::new();
    let clusters_dir = malai_home.join("clusters");
    
    if !clusters_dir.exists() {
        return Ok(roles);
    }
    
    // Scan all cluster directories
    if let Ok(entries) = std::fs::read_dir(&clusters_dir) {
        for entry in entries.flatten() {
            if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {
                let cluster_alias = entry.file_name().to_string_lossy().to_string();
                let cluster_dir = entry.path();
                
                // Check if this cluster has config
                let config_path = cluster_dir.join("cluster-config.toml");
                let cluster_info_path = cluster_dir.join("cluster-info.toml");
                
                if config_path.exists() {
                    // This machine is cluster manager for this cluster
                    roles.push((cluster_alias, MachineRole::ClusterManager));
                } else if cluster_info_path.exists() {
                    // This machine is a regular machine in this cluster  
                    let role = detect_machine_role_for_cluster(malai_home, &cluster_alias).await?;
                    roles.push((cluster_alias, role));
                }
            }
        }
    }
    
    Ok(roles)
}

/// Load or create state.json for cluster manager
fn load_cluster_state(cluster_dir: &PathBuf) -> Result<ClusterState> {
    let state_path = cluster_dir.join("state.json");
    
    if state_path.exists() {
        let state_content = std::fs::read_to_string(&state_path)?;
        let state: ClusterState = serde_json::from_str(&state_content)?;
        Ok(state)
    } else {
        // Create new state
        let cluster_alias = cluster_dir.file_name()
            .unwrap_or_default()
            .to_string_lossy()
            .to_string();
            
        let state = ClusterState {
            cluster_alias,
            cluster_config_hash: String::new(),
            last_distribution: None,
            machine_states: std::collections::HashMap::new(),
        };
        
        Ok(state)
    }
}

/// Save state.json for cluster manager
fn save_cluster_state(cluster_dir: &PathBuf, state: &ClusterState) -> Result<()> {
    let state_path = cluster_dir.join("state.json");
    let state_json = serde_json::to_string_pretty(state)?;
    std::fs::write(&state_path, state_json)?;
    Ok(())
}

/// Cluster manager state for config distribution tracking
#[derive(Debug, serde::Serialize, serde::Deserialize)]
struct ClusterState {
    cluster_alias: String,
    cluster_config_hash: String,
    last_distribution: Option<String>,
    machine_states: std::collections::HashMap<String, MachineState>,
}

/// Individual machine state within cluster
#[derive(Debug, serde::Serialize, serde::Deserialize)]
struct MachineState {
    machine_alias: String,
    last_config_hash: String,
    last_sync: Option<String>,
    sync_status: String, // "success", "pending", "failed"
}

/// Detect machine role for specific cluster
async fn detect_machine_role_for_cluster(malai_home: &PathBuf, cluster_alias: &str) -> Result<MachineRole> {
    let cluster_dir = malai_home.join("clusters").join(cluster_alias);
    let machine_config_path = cluster_dir.join("machine-config.toml");
    
    if !machine_config_path.exists() {
        return Ok(MachineRole::Unknown);
    }
    
    // TODO: Parse machine config to determine role
    // For now, assume client-only
    Ok(MachineRole::ClientOnly(cluster_alias.to_string()))
}

/// Start cluster manager for specific cluster
async fn start_cluster_manager_for_cluster(cluster_dir: PathBuf) -> Result<()> {
    let cluster_alias = cluster_dir.file_name().unwrap().to_string_lossy().to_string();
    println!("ğŸ“‹ Cluster Manager starting for: {}", cluster_alias);
    
    let config_path = cluster_dir.join("cluster-config.toml");
    let mut last_config_hash = String::new();
    
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(5)).await;
        
        // Check if config changed
        if let Ok(config_content) = std::fs::read_to_string(&config_path) {
            let current_hash = calculate_config_hash(&config_content);
            
            if current_hash != last_config_hash {
                println!("ğŸ“‹ Config changed for {}, distributing...", cluster_alias);
                last_config_hash = current_hash.clone();
                
                // Load state
                let mut state = load_cluster_state(&cluster_dir)?;
                state.cluster_config_hash = current_hash;
                
                // Find machines that need config updates
                let machines = extract_all_machine_ids(&config_content);
                for (machine_alias, machine_id52) in machines {
                    let needs_update = state.machine_states
                        .get(&machine_id52)
                        .map(|ms| ms.last_config_hash != state.cluster_config_hash)
                        .unwrap_or(true);
                    
                    if needs_update {
                        println!("ğŸ“¤ Sending config to {}", machine_alias);
                        // TODO: Send config via P2P
                        
                        // Update state
                        state.machine_states.insert(machine_id52.clone(), MachineState {
                            machine_alias: machine_alias.clone(),
                            last_config_hash: state.cluster_config_hash.clone(),
                            last_sync: Some(chrono::Utc::now().to_rfc3339()),
                            sync_status: "success".to_string(),
                        });
                    }
                }
                
                // Save state
                save_cluster_state(&cluster_dir, &state)?;
            }
        }
    }
}

/// Start SSH daemon for specific cluster
async fn start_ssh_daemon_for_cluster(cluster_dir: PathBuf, machine_name: String) -> Result<()> {
    let cluster_alias = cluster_dir.file_name().unwrap().to_string_lossy().to_string();
    println!("ğŸšª SSH Daemon starting for: {} (machine: {})", cluster_alias, machine_name);
    
    // TODO: Start P2P listener for SSH requests
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        // TODO: Handle incoming P2P SSH requests
        // TODO: Execute commands with permission checking
        // TODO: Send responses back via P2P
    }
}

/// Start config listener for cluster waiting for cluster manager
async fn start_config_listener_for_cluster(cluster_dir: PathBuf) -> Result<()> {
    let cluster_alias = cluster_dir.file_name().unwrap().to_string_lossy().to_string();
    println!("ğŸ“¡ Config Listener starting for: {} (waiting for cluster manager)", cluster_alias);
    
    // TODO: Start P2P listener for config updates
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        // TODO: Listen for config updates from cluster manager
        // TODO: Validate config sender against cluster-info.toml
        // TODO: Write received config to machine-config.toml
        // TODO: Trigger role detection and service restart if needed
    }
}

/// Start service proxy agent (TCP/HTTP forwarding)
async fn start_service_proxy_agent(malai_home: PathBuf) -> Result<()> {
    println!("ğŸŒ Service Proxy Agent starting for all clusters");
    
    let services_path = malai_home.join("services.toml");
    
    // TODO: Parse services.toml configuration
    // TODO: Start TCP port listeners for configured services
    // TODO: Start HTTP server on port 80 for subdomain routing
    // TODO: Forward connections to remote services via P2P
    
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        // TODO: Handle incoming TCP connections and HTTP requests
        // TODO: Route to appropriate remote services via P2P
        // TODO: Inject client identity headers for HTTP services
    }
}

/// Machine roles for agent
#[derive(Debug, PartialEq)]
enum MachineRole {
    ClusterManager,
    SshServer(String),
    ClientOnly(String), 
    Unknown,
}

/// Start cluster manager specific services
async fn start_cluster_manager_services(malai_home: &PathBuf) -> Result<()> {
    println!("ğŸ”§ Starting cluster manager services...");
    println!("   ğŸ“‚ Config monitoring: {}/malai/cluster-config.toml", malai_home.display());
    println!("   ğŸŒ P2P coordination: cluster member management");
    println!("   ğŸ“¤ Config distribution: syncing to all cluster machines");
    
    // Start config distribution service
    tokio::spawn(run_config_distribution(malai_home.clone()));
    
    Ok(())
}

/// Run cluster manager config distribution service
async fn run_config_distribution(malai_home: PathBuf) -> Result<()> {
    println!("ğŸ“¡ Starting config distribution service");
    
    let config_path = malai_home.join("cluster-config.toml");
    let mut last_config_hash = String::new();
    
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(5)).await;
        
        // Check if config file changed
        if let Ok(config_content) = std::fs::read_to_string(&config_path) {
            let current_hash = calculate_config_hash(&config_content);
            
            if current_hash != last_config_hash {
                println!("ğŸ“‹ Config file changed, distributing to cluster members...");
                last_config_hash = current_hash;
                
                // Find all machines in config and send them updated config
                match distribute_config_to_machines(&malai_home, &config_content).await {
                    Ok(()) => println!("âœ… Config distributed to all cluster members"),
                    Err(e) => println!("âŒ Config distribution failed: {}", e),
                }
            }
        }
    }
}

/// Distribute config to all machines in cluster
async fn distribute_config_to_machines(malai_home: &PathBuf, config_content: &str) -> Result<()> {
    // Parse all machine IDs from config
    let machine_ids = extract_all_machine_ids(config_content);
    println!("ğŸ“¤ Distributing config to {} machines", machine_ids.len());
    
    // Get local cluster manager identity
    let identity_file = malai_home.join("keys").join("identity.key");
    let secret_key_hex = std::fs::read_to_string(&identity_file)?;
    let local_secret = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
    
    for (machine_name, machine_id52) in machine_ids {
        println!("ğŸ“¨ Sending config to machine: {} ({})", machine_name, machine_id52);
        
        match send_config_to_machine(&local_secret, &machine_id52, config_content).await {
            Ok(()) => println!("âœ… Config sent to {}", machine_name),
            Err(e) => println!("âŒ Failed to send config to {}: {}", machine_name, e),
        }
    }
    
    Ok(())
}

/// Send config to a specific machine via P2P
async fn send_config_to_machine(
    local_secret: &fastn_id52::SecretKey,
    target_id52: &str, 
    config_content: &str
) -> Result<()> {
    todo!("Implement P2P config distribution with fastn_id52 to {}", target_id52)
}

/// Extract all machine IDs from config
fn extract_all_machine_ids(config_content: &str) -> Vec<(String, String)> {
    let mut machines = Vec::new();
    
    for line in config_content.lines() {
        if line.trim().starts_with("[machine.") && !line.trim().starts_with('#') {
            if let Some(machine_name) = line.strip_prefix("[machine.").and_then(|s| s.strip_suffix("]")) {
                // Find the machine's ID52 in the following lines
                if let Some(section_start) = config_content.find(line) {
                    let remaining = &config_content[section_start..];
                    let section_end = remaining.find("\n[").unwrap_or(remaining.len());
                    let machine_section = &remaining[..section_end];
                    
                    if let Some(id52_line) = machine_section.lines().find(|l| l.trim().starts_with("id52") && !l.trim().starts_with('#')) {
                        let id52 = id52_line.split('=').nth(1).unwrap_or("").trim().trim_matches('"');
                        machines.push((machine_name.to_string(), id52.to_string()));
                    }
                }
            }
        }
    }
    
    machines
}

/// Calculate hash of config content for change detection
fn calculate_config_hash(content: &str) -> String {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    
    let mut hasher = DefaultHasher::new();
    content.hash(&mut hasher);
    format!("{:x}", hasher.finish())
}

/// Run config listener for machines waiting for cluster manager config
async fn run_config_listener(malai_home: PathBuf) -> Result<()> {
    println!("ğŸ“¡ Starting config listener for cluster manager updates");
    
    // Get local identity
    let identity_file = malai_home.join("keys").join("identity.key");
    if !identity_file.exists() {
        return Err(eyre::eyre!("No machine identity found - run 'malai ssh init' first"));
    }
    
    let secret_key_hex = std::fs::read_to_string(&identity_file)?;
    let local_secret = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
    let fastn_secret = fastn_id52::SecretKey::from_bytes(&local_secret.to_bytes());
    
    println!("ğŸ†” Listening for config updates for machine: {}", local_secret.id52());
    
    // Start listening for config sync requests
    let protocols = vec![SshProtocol::ConfigSync];
    
    todo!("Implement fastn-p2p config listener - machines must receive config from cluster manager")
}

/// Start SSH server specific services
async fn start_ssh_server_services(malai_home: &PathBuf, machine_name: &str) -> Result<()> {
    println!("ğŸ”§ Starting SSH server services for machine '{}'...", machine_name);
    
    // Check that we have proper config from cluster manager
    let config_path = malai_home.join("cluster-config.toml");
    if !config_path.exists() {
        panic!("FATAL: SSH server cannot start without cluster config from cluster manager");
    }
    
    // Verify config is properly synced (not just generated locally)
    let config_content = std::fs::read_to_string(&config_path)?;
    if !config_content.contains("[cluster_manager]") {
        panic!("FATAL: Invalid cluster config - missing cluster_manager section");
    }
    
    println!("âœ… Valid cluster config received from cluster manager");
    println!("   ğŸšª SSH listener: accepting incoming connections");
    println!("   ğŸŒ P2P communication: fastn-p2p protocol handling");
    println!("   ğŸ” Permission checking: command and service access control");
    
    // Start P2P SSH server
    tokio::spawn(run_ssh_server(malai_home.clone(), machine_name.to_string()));
    
    Ok(())
}

/// Run SSH server that listens for P2P requests
async fn run_ssh_server(malai_home: PathBuf, machine_name: String) -> Result<()> {
    println!("ğŸ§ Starting SSH P2P listener for machine: {}", machine_name);
    
    // Get local identity
    let identity_file = malai_home.join("keys").join("identity.key");
    let secret_key_hex = std::fs::read_to_string(&identity_file)?;
    let local_secret = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
    
    // Convert to fastn_id52 for P2P
    let fastn_secret = fastn_id52::SecretKey::from_bytes(&local_secret.to_bytes());
    
    // Start listening for SSH execution requests
    let protocols = vec![SshProtocol::Execute];
    
    todo!("Implement P2P SSH server listener - no simulation")
}

/// Start client-only services  
async fn start_client_services(malai_home: &PathBuf, machine_name: &str) -> Result<()> {
    println!("ğŸ”§ Starting client services for machine '{}'...", machine_name);
    println!("   ğŸŒ P2P client: outbound connection management");
    println!("   ğŸ•¸ï¸  HTTP proxy: transparent service access");
    println!("   ğŸ”§ Connection pooling: efficient remote access");
    
    // TODO: Implement actual client functionality
    // - HTTP proxy for transparent service access
    // - Connection pooling for SSH commands
    // - Config sync from cluster manager
    
    Ok(())
}

