/// Simple remote access utilities for CLI commands
/// This module provides the basic functionality needed for remote access commands
/// without the complex fastn-p2p integration

use eyre::Result;
use std::path::PathBuf;
use std::str::FromStr;

/// Get MALAI_HOME directory with proper defaults
pub fn get_malai_home() -> PathBuf {
    if let Ok(malai_home) = std::env::var("MALAI_HOME") {
        PathBuf::from(malai_home)
    } else {
        get_default_malai_home()
    }
}

/// Get default MALAI_HOME directory based on platform
pub fn get_default_malai_home() -> PathBuf {
    if let Some(data_dir) = dirs::data_dir() {
        data_dir.join("malai")
    } else {
        // Fallback to current directory
        std::env::current_dir().unwrap_or_default().join(".malai")
    }
}

/// Initialize cluster with required cluster name
pub async fn init_cluster(cluster_name: String) -> Result<()> {
    println!("🏗️  Creating cluster...");
    
    let malai_home = get_malai_home();
    let cluster_dir = malai_home.join("clusters").join(&cluster_name);
    
    // Ensure cluster directory exists
    std::fs::create_dir_all(&cluster_dir)?;
    
    // Generate or read existing cluster manager identity
    let identity_dir = malai_home.join("keys");
    std::fs::create_dir_all(&identity_dir)?;
    
    let identity_file = identity_dir.join("identity.key");
    let (cluster_manager_id52, cluster_manager_secret) = if identity_file.exists() {
        // Read existing identity
        let secret_key_hex = std::fs::read_to_string(&identity_file)?;
        let secret_key = fastn_id52::SecretKey::from_str(&secret_key_hex.trim())?;
        let id52 = secret_key.id52();
        (id52, secret_key)
    } else {
        // Generate new identity
        let (id52, secret_key) = { let secret_key = fastn_id52::SecretKey::generate(); (secret_key.id52(), secret_key) };
        // Save to file
        std::fs::write(&identity_file, secret_key.to_string())?;
        (id52, secret_key)
    };
    
    println!("📝 Generated cluster manager identity: {}", cluster_manager_id52);
    
    // Create basic cluster config  
    let cluster_config = format!(
        r#"# Malai Cluster Configuration
# Generated by: malai cluster init {}
# Cluster Name: {}
# Cluster Manager: {}

[cluster_manager]
id52 = "{}"
cluster_name = "{}"
use_keyring = true

# Add machines to this cluster by editing this file
# Examples:

# Basic machine (accepts remote access)
# [machine.web01]
# id52 = "machine-id52-here"
# accept_ssh = true
# allow_from = "*"

# With command aliases
# [machine.web01.command.restart-nginx]
# allow_from = "admins"
# command = "sudo systemctl restart nginx"

# With HTTP services  
# [machine.web01.http.admin]
# port = 8080
# allow_from = "admins"
# secure = false
"#,
        cluster_name,
        cluster_name,
        cluster_manager_id52,
        cluster_manager_id52,
        cluster_name
    );
    
    let config_path = cluster_dir.join("cluster-config.toml");
    std::fs::write(&config_path, cluster_config)?;
    
    println!("✅ Cluster configuration created at: {}", config_path.display());
    println!("Cluster created with ID: {}", cluster_manager_id52);
    println!("Cluster name: {}", cluster_name);
    
    Ok(())
}

/// Show cluster information
pub async fn show_cluster_info() -> Result<()> {
    println!("📋 Cluster Information:");
    
    let malai_home = get_malai_home();
    let config_path = malai_home.join("cluster-config.toml");
    
    if !config_path.exists() {
        println!("❌ No cluster configuration found at: {}", config_path.display());
        println!("💡 Create a cluster with: malai ssh create-cluster");
        return Ok(());
    }
    
    // Read config to determine role
    let config_content = std::fs::read_to_string(&config_path)?;
    println!("📄 Config path: {}", config_path.display());
    
    // Parse basic info (simple parsing, not full TOML)
    if let Some(manager_line) = config_content.lines().find(|l| l.starts_with("id52 = ") && !l.contains("[machine.")) {
        let cluster_id = manager_line
            .split('"')
            .nth(1)
            .unwrap_or("unknown");
        println!("🆔 Cluster ID: {}", cluster_id);
        
        // Check local identity to determine role
        let identity_file = malai_home.join("keys").join("identity.key");
        if identity_file.exists() {
            if let Ok(secret_key_hex) = std::fs::read_to_string(&identity_file) {
                if let Ok(secret_key) = fastn_id52::SecretKey::from_str(secret_key_hex.trim()) {
                    let local_id52 = secret_key.id52();
            
                    if local_id52 == cluster_id {
                        println!("👑 Role: cluster-manager");
                    } else if config_content.contains(&local_id52) {
                        // Find machine name
                        for line in config_content.lines() {
                            if line.contains(&local_id52) {
                                if let Some(machine_section) = config_content.lines().rev().find(|l| l.starts_with("[machine.") && config_content[config_content.find(l).unwrap()..].contains(&local_id52)) {
                                    let machine_name = machine_section
                                        .trim_start_matches("[machine.")
                                        .trim_end_matches("]");
                                    
                                    let machine_section_start = config_content.find(machine_section).unwrap();
                                    let machine_config = &config_content[machine_section_start..];
                                    if machine_config.split("[").next().unwrap().contains("accept_ssh = true") {
                                        println!("🖥️  Role: remote access server ({})", machine_name);
                                    } else {
                                        println!("💻 Role: client-only ({})", machine_name);
                                    }
                                    break;
                                }
                            }
                        }
                    } else {
                        println!("❓ Role: unknown (not found in cluster config)");
                    }
                }
            }
        }
    }
    
    Ok(())
}

/// Initialize machine for cluster with alias (new top-level API)  
pub async fn init_machine_for_cluster_with_alias(cluster_manager: String, cluster_alias: String) -> Result<()> {
    println!("🏗️  Initializing machine for cluster...");
    println!("🎯 Cluster: {} (alias: {})", cluster_manager, cluster_alias);
    
    let malai_home = get_malai_home();
    let identity_dir = malai_home.join("keys");
    std::fs::create_dir_all(&identity_dir)?;
    
    let identity_file = identity_dir.join("identity.key");
    
    if identity_file.exists() {
        println!("⚠️  Machine already initialized");
        let secret_key_hex = std::fs::read_to_string(&identity_file)?;
        let secret_key = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
        let machine_id52 = secret_key.id52();
        println!("🆔 Existing machine ID: {}", machine_id52);
        return Ok(());
    }
    
    // Generate new machine identity
    let (machine_id52, machine_secret) = { let secret_key = fastn_id52::SecretKey::generate(); (secret_key.id52(), secret_key) };
    std::fs::write(&identity_file, machine_secret.to_string())?;
    
    println!("📝 Generated machine identity: {}", machine_id52);
    
    // Contact cluster manager and create cluster-specific directory
    println!("🔗 Contacting cluster manager: {}", cluster_manager);
    match contact_cluster_manager(&cluster_manager, &machine_id52, &malai_home).await {
        Ok(cluster_manager_id52) => {
            // Create cluster-specific directory
            let cluster_dir = malai_home.join("clusters").join(&cluster_alias);
            std::fs::create_dir_all(&cluster_dir)?;
            
            // Save cluster info
            let cluster_info = format!(
                r#"# Cluster registration information
cluster_alias = "{}"
cluster_id52 = "{}"
machine_id52 = "{}"
"#,
                cluster_alias, cluster_manager_id52, machine_id52
            );
            
            std::fs::write(cluster_dir.join("cluster-info.toml"), cluster_info)?;
            
            println!("✅ Machine registered with cluster: {} (alias: {})", cluster_manager, cluster_alias);
            println!("Machine created with ID: {}", machine_id52);
            println!("📋 Next steps:");
            println!("1. Cluster admin will add your machine to cluster config");
            println!("2. Start services: malai start");
        }
        Err(e) => {
            println!("❌ Failed to contact cluster manager: {}", e);
            println!("Machine created with ID: {}", machine_id52);
            println!("📋 Manual steps required:");
            println!("1. Share machine ID with cluster administrator: {}", machine_id52);
            println!("2. Admin should add machine to cluster config");
        }
    }
    
    Ok(())
}

/// Legacy function - initialize machine for cluster (generates identity, contacts cluster manager)
pub async fn init_machine_for_cluster(cluster: String) -> Result<()> {
    // Extract alias from cluster string or use a default
    let cluster_alias = if cluster.contains('.') {
        cluster.split('.').next().unwrap_or("default").to_string()
    } else {
        "default".to_string()
    };
    
    init_machine_for_cluster_with_alias(cluster, cluster_alias).await
}

/// Contact cluster manager to register machine and get cluster manager ID52
async fn contact_cluster_manager(cluster: &str, machine_id52: &str, malai_home: &PathBuf) -> Result<String> {
    println!("🔍 Resolving cluster manager for: {}", cluster);
    
    // Try to resolve cluster name (domain or direct ID52)
    let cluster_manager_id52 = if cluster.contains('.') {
        // Domain name - TODO: implement DNS TXT record lookup
        println!("🌐 Cluster appears to be domain name: {}", cluster);
        println!("💡 DNS TXT record lookup not yet implemented");
        return Err(eyre::eyre!("DNS resolution not yet implemented"));
    } else {
        // Assume it's a direct cluster manager ID52
        println!("🆔 Using cluster as direct cluster manager ID52");
        cluster.to_string()
    };
    
    // TODO: Contact cluster manager via P2P to register this machine
    println!("📡 Would contact cluster manager {} to register machine {}", cluster_manager_id52, machine_id52);
    
    todo!("Implement P2P registration with cluster manager");
}

/// Legacy function for backward compatibility
pub async fn create_cluster(alias: Option<String>) -> Result<()> {
    let cluster_name = alias.unwrap_or_else(|| "default".to_string());
    init_cluster(cluster_name).await
}

/// Legacy function for backward compatibility  
pub async fn init_machine() -> Result<()> {
    println!("❌ Machine init requires cluster name");
    println!("💡 Usage: malai ssh machine init <cluster-name-or-id52>");
    println!("💡 Example: malai ssh machine init company");
    Ok(())
}

/// Start malai daemon with lockfile and daemonization
pub async fn start_malai_daemon(environment: bool, foreground: bool) -> Result<()> {
    if environment {
        // Print environment variables for shell integration
        let malai_home = get_malai_home();
        println!("MALAI_HOME={}", malai_home.display());
        println!("MALAI_DAEMON_SOCK={}", malai_home.join("malai.sock").display());
        return Ok(());
    }
    
    let malai_home = get_malai_home();
    println!("🚀 Starting malai daemon...");
    println!("📁 MALAI_HOME: {}", malai_home.display());
    
    // Acquire exclusive lock (following fastn-rig pattern)
    let lock_path = malai_home.join("malai.lock");
    let lock_file = std::fs::OpenOptions::new()
        .create(true)
        .truncate(false)
        .write(true)
        .open(&lock_path)?;
    
    match lock_file.try_lock() {
        Ok(()) => {
            println!("🔒 Lock acquired: {}", lock_path.display());
        }
        Err(_) => {
            println!("❌ Another malai daemon already running at {}", malai_home.display());
            return Ok(());
        }
    }
    
    let _lock_guard = lock_file; // Hold lock for daemon lifetime
    
    // Daemonize unless in foreground mode
    if !foreground {
        println!("🔄 Daemonizing (use --foreground to stay in terminal)...");
        // TODO: Implement actual fork/daemonize  
        println!("📋 For now running in foreground (daemonization not yet implemented)");
    } else {
        println!("📋 Running in foreground mode");
    }
    
    // Load and validate ALL configs before daemonizing
    let validated_configs = load_and_validate_all_configs(&malai_home).await?;
    println!("✅ All configurations validated successfully");
    
    println!("✅ malai daemon started");
    println!("💡 Use 'malai daemon -e' for environment variables");
    println!("📨 malai daemon running. Press Ctrl+C to stop.");
    
    // Start services based on validated configs
    start_services_from_configs(validated_configs).await?;
    
    // Wait for graceful shutdown using fastn-p2p global singleton
    fastn_p2p::cancelled().await;
    
    println!("👋 malai daemon stopped gracefully");
    Ok(())
}

/// Load and validate all configurations in MALAI_HOME
async fn load_and_validate_all_configs(malai_home: &PathBuf) -> Result<ValidatedConfigs> {
    println!("🔍 Loading and validating all configurations...");
    
    let clusters_dir = malai_home.join("clusters");
    let mut cluster_configs = Vec::new();
    let mut machine_configs = Vec::new();
    
    if !clusters_dir.exists() {
        println!("📂 No clusters directory - daemon will run with no clusters");
        return Ok(ValidatedConfigs {
            cluster_configs,
            machine_configs,
            waiting_machines: Vec::new(),
        });
    }
    
    // Scan all cluster directories
    if let Ok(entries) = std::fs::read_dir(&clusters_dir) {
        for entry in entries.flatten() {
            if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {
                let cluster_alias = entry.file_name().to_string_lossy().to_string();
                let cluster_dir = entry.path();
                
                println!("📋 Validating cluster: {}", cluster_alias);
                
                // Check for cluster-config.toml (cluster manager role)
                let config_path = cluster_dir.join("cluster-config.toml");
                if config_path.exists() {
                    match validate_cluster_config(&config_path, &cluster_alias).await {
                        Ok(config) => {
                            cluster_configs.push(config);
                            println!("   ✅ cluster-config.toml validated");
                        }
                        Err(e) => {
                            println!("   ❌ cluster-config.toml validation failed: {}", e);
                            return Err(eyre::eyre!("Invalid cluster config for {}: {}", cluster_alias, e));
                        }
                    }
                }
                
                // Check for machine-config.toml (machine role)  
                let machine_config_path = cluster_dir.join("machine-config.toml");
                if machine_config_path.exists() {
                    match validate_machine_config(&machine_config_path, &cluster_alias).await {
                        Ok(config) => {
                            machine_configs.push(config);
                            println!("   ✅ machine-config.toml validated");
                        }
                        Err(e) => {
                            println!("   ❌ machine-config.toml validation failed: {}", e);
                            return Err(eyre::eyre!("Invalid machine config for {}: {}", cluster_alias, e));
                        }
                    }
                }
                
                // Validate identity.key if present
                let identity_path = cluster_dir.join("identity.key");
                if identity_path.exists() {
                    if let Err(e) = validate_identity_file(&identity_path) {
                        println!("   ❌ identity.key validation failed: {}", e);
                        return Err(eyre::eyre!("Invalid identity for {}: {}", cluster_alias, e));
                    } else {
                        println!("   ✅ identity.key validated");
                    }
                }
            }
        }
    }
    
    println!("✅ Configuration validation complete:");
    println!("   📊 Cluster manager roles: {}", cluster_configs.len());
    println!("   📊 Machine roles: {}", machine_configs.len());
    
    // Also check for machines waiting for config (cluster-info.toml without machine-config.toml)
    let mut waiting_machines = Vec::new();
    if let Ok(entries) = std::fs::read_dir(&clusters_dir) {
        for entry in entries.flatten() {
            if entry.file_type().map(|t| t.is_dir()).unwrap_or(false) {
                let cluster_alias = entry.file_name().to_string_lossy().to_string();
                let cluster_dir = entry.path();
                
                let cluster_info_path = cluster_dir.join("cluster-info.toml");
                let machine_config_path = cluster_dir.join("machine-config.toml");
                
                // Machine registered but no config received yet
                if cluster_info_path.exists() && !machine_config_path.exists() {
                    waiting_machines.push(WaitingMachine {
                        cluster_alias: cluster_alias.clone(),
                        cluster_dir: cluster_dir.clone(),
                    });
                    println!("   📋 Machine waiting for config in cluster: {}", cluster_alias);
                }
            }
        }
    }
    
    Ok(ValidatedConfigs {
        cluster_configs,
        machine_configs,
        waiting_machines,
    })
}

/// Validated configuration structure
#[derive(Debug)]
struct ValidatedConfigs {
    cluster_configs: Vec<ClusterConfig>,
    machine_configs: Vec<MachineConfig>,
    waiting_machines: Vec<WaitingMachine>,
}

/// Machine waiting for config from cluster manager
#[derive(Debug)]
struct WaitingMachine {
    cluster_alias: String,
    cluster_dir: std::path::PathBuf,
}

/// Cluster manager configuration
#[derive(Debug)]  
struct ClusterConfig {
    cluster_alias: String,
    config_path: std::path::PathBuf,
    config_content: String,
    config_hash: String,
}

/// Machine configuration
#[derive(Debug, Clone)]
struct MachineConfig {
    cluster_alias: String,  
    config_path: std::path::PathBuf,
    config_content: String,
    machine_role: String, // "ssh-daemon" or "client-only"
}

/// Validate cluster config file
async fn validate_cluster_config(config_path: &std::path::Path, cluster_alias: &str) -> Result<ClusterConfig> {
    let config_content = std::fs::read_to_string(config_path)?;
    
    // Basic TOML syntax validation
    let _parsed: toml::Value = toml::from_str(&config_content)
        .map_err(|e| eyre::eyre!("TOML syntax error: {}", e))?;
    
    // TODO: Add semantic validation (machine refs, groups, etc.)
    
    let config_hash = calculate_config_hash(&config_content);
    
    Ok(ClusterConfig {
        cluster_alias: cluster_alias.to_string(),
        config_path: config_path.to_path_buf(),
        config_content,
        config_hash,
    })
}

/// Validate machine config file
async fn validate_machine_config(config_path: &std::path::Path, cluster_alias: &str) -> Result<MachineConfig> {
    let config_content = std::fs::read_to_string(config_path)?;
    
    // Basic TOML syntax validation
    let _parsed: toml::Value = toml::from_str(&config_content)
        .map_err(|e| eyre::eyre!("TOML syntax error: {}", e))?;
    
    // TODO: Determine machine role from config
    let machine_role = "client-only".to_string(); // Placeholder
    
    Ok(MachineConfig {
        cluster_alias: cluster_alias.to_string(),
        config_path: config_path.to_path_buf(),
        config_content,
        machine_role,
    })
}

/// Validate identity key file
fn validate_identity_file(identity_path: &std::path::Path) -> Result<()> {
    let key_content = std::fs::read_to_string(identity_path)?;
    let _secret_key = fastn_id52::SecretKey::from_str(key_content.trim())
        .map_err(|e| eyre::eyre!("Invalid secret key format: {}", e))?;
    
    Ok(())
}

/// Calculate config hash for change detection
fn calculate_config_hash(content: &str) -> String {
    use std::collections::hash_map::DefaultHasher;
    use std::hash::{Hash, Hasher};
    
    let mut hasher = DefaultHasher::new();
    content.hash(&mut hasher);
    format!("{:x}", hasher.finish())
}

/// Scan MALAI_HOME and report configurations  
async fn scan_and_report_configs(malai_home: &PathBuf) -> Result<()> {
    println!("🔍 Scanning for configurations...");
    
    let clusters_dir = malai_home.join("clusters");
    
    if !clusters_dir.exists() {
        println!("❌ No clusters directory found");
        println!("💡 Initialize a cluster: malai cluster init <name>");
        return Ok(());
    }
    
    println!("📂 Clusters directory: {}", clusters_dir.display());
    
    // Simple cluster count for now
    if let Ok(entries) = std::fs::read_dir(&clusters_dir) {
        let cluster_count = entries.filter(|entry| {
            entry.as_ref().map(|e| e.file_type().map(|t| t.is_dir()).unwrap_or(false)).unwrap_or(false)
        }).count();
        
        println!("📊 Found {} cluster directories", cluster_count);
    }
    
    Ok(())
}

/// Show detailed daemon and cluster status
pub async fn show_detailed_status() -> Result<()> {
    let malai_home = get_malai_home();
    
    println!("📊 malai Status");
    println!("═══════════════════════════════════════");
    println!("📁 MALAI_HOME: {}", malai_home.display());
    
    // Check daemon status
    let lockfile_path = malai_home.join("malai.lock");
    if lockfile_path.exists() {
        println!("🔒 Daemon: RUNNING (lockfile exists)");
    } else {
        println!("💤 Daemon: NOT RUNNING");
    }
    
    // Load and show all configs
    match load_and_validate_all_configs(&malai_home).await {
        Ok(configs) => {
            println!("\n🏗️  Cluster Configurations:");
            if configs.cluster_configs.is_empty() {
                println!("   ❌ No cluster manager roles");
            } else {
                for cluster_config in &configs.cluster_configs {
                    println!("   👑 {} (Cluster Manager)", cluster_config.cluster_alias);
                    println!("      📄 Config: {}", cluster_config.config_path.display());
                    println!("      🔢 Hash: {}", cluster_config.config_hash);
                    
                    // Count machines in cluster
                    let machine_count = cluster_config.config_content.lines()
                        .filter(|line| line.trim().starts_with("[machine.") && !line.trim().starts_with('#'))
                        .count();
                    println!("      📊 Machines: {}", machine_count);
                    
                    // Show sync status from state.json
                    let state_path = cluster_config.config_path.parent().unwrap().join("state.json");
                    if state_path.exists() {
                        if let Ok(state_content) = std::fs::read_to_string(&state_path) {
                            if let Ok(state) = serde_json::from_str::<serde_json::Value>(&state_content) {
                                if let Some(machine_states) = state.get("machine_states") {
                                    if let Some(machine_states_obj) = machine_states.as_object() {
                                        println!("      📡 Config Sync Status:");
                                        for (machine_id52, machine_state) in machine_states_obj {
                                            if let Some(machine_alias) = machine_state.get("machine_alias") {
                                                if let Some(sync_status) = machine_state.get("sync_status") {
                                                    if let Some(last_sync) = machine_state.get("last_sync") {
                                                        println!("         {} ({}): {} at {}", 
                                                               machine_alias.as_str().unwrap_or("unknown"),
                                                               &machine_id52[..8],
                                                               sync_status.as_str().unwrap_or("unknown"),
                                                               last_sync.as_str().unwrap_or("unknown"));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        println!("      ⚠️  No sync status (state.json not found)");
                    }
                }
            }
            
            println!("\n🖥️  Machine Configurations:");
            if configs.machine_configs.is_empty() {
                println!("   ❌ No machine roles");
            } else {
                for machine_config in &configs.machine_configs {
                    println!("   🖥️  {} ({})", machine_config.cluster_alias, machine_config.machine_role);
                    println!("      📄 Config: {}", machine_config.config_path.display());
                }
            }
            
            println!("\n📡 Services:");
            let services_path = malai_home.join("services.toml");
            if services_path.exists() {
                println!("   📄 services.toml found");
                // TODO: Parse and show service configurations
            } else {
                println!("   ❌ No services.toml (no local service forwarding)");
            }
        }
        Err(e) => {
            println!("❌ Configuration validation failed: {}", e);
        }
    }
    
    Ok(())
}

/// Start services based on validated configurations
async fn start_services_from_configs(configs: ValidatedConfigs) -> Result<()> {
    // Start cluster managers
    for cluster_config in configs.cluster_configs {
        println!("👑 Starting cluster manager for: {}", cluster_config.cluster_alias);
        
        fastn_p2p::spawn(async move {
            if let Err(e) = run_cluster_manager(cluster_config).await {
                println!("❌ Cluster manager failed for {}: {}", e, "cluster");
            }
        });
    }
    
    // Start remote access daemons  
    for machine_config in configs.machine_configs {
        println!("🖥️  Starting remote access daemon for: {}", machine_config.cluster_alias);
        
        fastn_p2p::spawn(async move {
            if let Err(e) = run_ssh_daemon(machine_config).await {
                println!("❌ remote access daemon failed for {}: {}", e, "machine");
            }
        });
    }
    
    // Start config listeners for machines waiting for config
    for waiting_machine in configs.waiting_machines {
        println!("📡 Starting config listener for: {}", waiting_machine.cluster_alias);
        
        fastn_p2p::spawn(async move {
            if let Err(e) = run_config_listener(waiting_machine).await {
                println!("❌ Config listener failed for {}: {}", e, "waiting_machine");
            }
        });
    }
    
    // Always start service proxy
    println!("📡 Starting service proxy for all clusters");
    fastn_p2p::spawn(async move {
        if let Err(e) = run_service_proxy().await {
            println!("❌ Service proxy failed: {}", e);
        }
    });
    
    Ok(())
}

/// Run cluster manager for a specific cluster
async fn run_cluster_manager(cluster_config: ClusterConfig) -> Result<()> {
    println!("📋 Cluster manager starting for: {}", cluster_config.cluster_alias);
    
    let cluster_dir = cluster_config.config_path.parent().unwrap();
    let mut last_config_hash = cluster_config.config_hash.clone();
    
    // Initial config distribution on startup
    println!("📋 Initial config distribution for {}", cluster_config.cluster_alias);
    match distribute_personalized_configs(&cluster_config.config_content, cluster_dir).await {
        Ok(()) => println!("✅ Initial config distributed to all machines in {}", cluster_config.cluster_alias),
        Err(e) => println!("❌ Initial config distribution failed for {}: {}", cluster_config.cluster_alias, e),
    }
    
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(5)).await;
        
        // Check if config file changed
        if let Ok(new_content) = std::fs::read_to_string(&cluster_config.config_path) {
            let new_hash = calculate_config_hash(&new_content);
            
            if new_hash != last_config_hash {
                println!("📋 Config changed for {}, distributing...", cluster_config.cluster_alias);
                last_config_hash = new_hash;
                
                // Generate personalized configs for each machine
                match distribute_personalized_configs(&new_content, cluster_dir).await {
                    Ok(()) => println!("✅ Config distributed to all machines in {}", cluster_config.cluster_alias),
                    Err(e) => println!("❌ Config distribution failed for {}: {}", cluster_config.cluster_alias, e),
                }
            }
        }
        
        // Check for graceful shutdown
        tokio::select! {
            _ = tokio::time::sleep(std::time::Duration::from_secs(1)) => {}
            _ = fastn_p2p::cancelled() => {
                println!("🛑 Cluster manager {} stopping gracefully", cluster_config.cluster_alias);
                break;
            }
        }
    }
    
    Ok(())
}

/// Distribute personalized configs to all machines in cluster
async fn distribute_personalized_configs(master_config: &str, cluster_dir: &std::path::Path) -> Result<()> {
    // Parse master config to find all machines
    let master: toml::Value = toml::from_str(master_config)?;
    
    if let Some(machine_section) = master.get("machine") {
        if let Some(machine_table) = machine_section.as_table() {
            for (machine_alias, machine_config) in machine_table {
                if let Some(machine_config_table) = machine_config.as_table() {
                    if let Some(id52_value) = machine_config_table.get("id52") {
                        if let Some(machine_id52) = id52_value.as_str() {
                            println!("📤 Generating personalized config for machine: {}", machine_alias);
                            
                            match generate_personalized_config(master_config, machine_id52) {
                                Ok(personalized_config) => {
                                    let config_hash = calculate_config_hash(&personalized_config);
                                    println!("   📄 Personalized config hash: {}", config_hash);
                                    
                                    // Send personalized config via P2P
                                    match send_config_to_machine_p2p(machine_id52, &personalized_config).await {
                                        Ok(()) => {
                                            println!("   ✅ Config sent to {} via P2P", machine_alias);
                                            update_machine_state(cluster_dir, machine_id52, machine_alias, &personalized_config, &config_hash)?;
                                        }
                                        Err(e) => {
                                            println!("   ❌ P2P config send failed to {}: {}", machine_alias, e);
                                        }
                                    }
                                }
                                Err(e) => {
                                    println!("   ❌ Failed to generate config for {}: {}", machine_alias, e);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    Ok(())
}

/// Update machine state in state.json
fn update_machine_state(
    cluster_dir: &std::path::Path, 
    machine_id52: &str, 
    machine_alias: &str,
    personalized_config: &str,
    config_hash: &str
) -> Result<()> {
    let state_path = cluster_dir.join("state.json");
    
    // Load or create state
    let mut state = if state_path.exists() {
        let state_content = std::fs::read_to_string(&state_path)?;
        serde_json::from_str(&state_content)?
    } else {
        serde_json::json!({
            "cluster_alias": cluster_dir.file_name().unwrap().to_string_lossy(),
            "machine_states": {}
        })
    };
    
    // Update machine state
    state["machine_states"][machine_id52] = serde_json::json!({
        "machine_alias": machine_alias,
        "personalized_config": personalized_config,
        "personalized_config_hash": config_hash,
        "last_sync": chrono::Utc::now().to_rfc3339(),
        "sync_status": "generated"
    });
    
    // Save state
    let state_json = serde_json::to_string_pretty(&state)?;
    std::fs::write(&state_path, state_json)?;
    
    println!("   💾 Updated state for machine: {}", machine_alias);
    Ok(())
}

/// Run remote access daemon (accepts SSH commands via P2P)
async fn run_ssh_daemon(machine_config: MachineConfig) -> Result<()> {
    let cluster_alias = machine_config.cluster_alias.clone();
    println!("🚪 Remote access daemon starting for: {}", cluster_alias);
    
    // Get machine identity
    let identity_path = machine_config.config_path.parent().unwrap().join("identity.key");
    if !identity_path.exists() {
        return Err(eyre::eyre!("No machine identity found"));
    }
    
    let secret_key_hex = std::fs::read_to_string(&identity_path)?;
    let machine_secret = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
    
    println!("🆔 Remote access daemon ID52: {}", machine_secret.id52());
    println!("📡 Listening for remote access requests...");
    
    // Start P2P listener for both config sync AND remote access
    let protocols = vec![
        MalaiProtocol::ConfigUpdate, 
        MalaiProtocol::ExecuteCommand
    ];
    
    use futures_util::stream::StreamExt;
    let request_stream = fastn_p2p::server::listen(machine_secret.clone(), &protocols)?;
    let mut request_stream = std::pin::pin!(request_stream);
    
    loop {
        tokio::select! {
            request_result = request_stream.next() => {
                match request_result {
                    Some(Ok(request)) => {
                        let protocol = request.protocol().clone();
                        println!("📨 Received P2P request: {}", protocol);
                        
                        let machine_config_clone = machine_config.clone();
                        fastn_p2p::spawn(async move {
                            if let Err(e) = dispatch_protocol_request(request, machine_config_clone).await {
                                println!("❌ Protocol request handling failed: {}", e);
                            }
                        });
                    }
                    Some(Err(e)) => {
                        println!("❌ P2P request error: {}", e);
                    }
                    None => {
                        println!("📡 Remote access listener stream ended");
                        break;
                    }
                }
            }
            _ = fastn_p2p::cancelled() => {
                println!("🛑 Remote access daemon {} stopping gracefully", cluster_alias);
                break;
            }
        }
    }
    
    Ok(())
}

/// Run service proxy (placeholder)
async fn run_service_proxy() -> Result<()> {
    println!("🌐 Service proxy starting");
    
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        
        // Check for graceful shutdown  
        tokio::select! {
            _ = tokio::time::sleep(std::time::Duration::from_secs(1)) => {}
            _ = fastn_p2p::cancelled() => {
                println!("🛑 Service proxy stopping gracefully");
                break;
            }
        }
    }
    
    Ok(())
}

/// Run config listener for machine waiting for cluster manager config
async fn run_config_listener(waiting_machine: WaitingMachine) -> Result<()> {
    println!("📡 Config listener starting for: {}", waiting_machine.cluster_alias);
    
    // Get machine identity for this cluster
    let identity_path = waiting_machine.cluster_dir.join("identity.key");
    if !identity_path.exists() {
        return Err(eyre::eyre!("No machine identity found"));
    }
    
    let secret_key_hex = std::fs::read_to_string(&identity_path)?;
    let machine_secret = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
    
    println!("🆔 Machine ID52: {}", machine_secret.id52());
    println!("📡 Listening for config updates...");
    
    // Start P2P listener for config sync protocol only
    let protocols = vec![MalaiProtocol::ConfigUpdate];
    
    use futures_util::stream::StreamExt;
    let request_stream = fastn_p2p::server::listen(machine_secret.clone(), &protocols)?;
    let mut request_stream = std::pin::pin!(request_stream);
    
    loop {
        tokio::select! {
            request_result = request_stream.next() => {
                match request_result {
                    Some(Ok(request)) => {
                        println!("📨 Received config update request");
                        
                        let cluster_dir = waiting_machine.cluster_dir.clone();
                        fastn_p2p::spawn(async move {
                            if let Err(e) = handle_config_update_protocol(request, cluster_dir).await {
                                println!("❌ Config update handling failed: {}", e);
                            }
                        });
                    }
                    Some(Err(e)) => {
                        println!("❌ P2P request error: {}", e);
                    }
                    None => {
                        println!("📡 Config listener stream ended");
                        break;
                    }
                }
            }
            _ = fastn_p2p::cancelled() => {
                println!("🛑 Config listener {} stopping gracefully", waiting_machine.cluster_alias);
                break;
            }
        }
    }
    
    Ok(())
}

/// Dispatch protocol request to appropriate handler
async fn dispatch_protocol_request(
    request: fastn_p2p::server::Request<MalaiProtocol>,
    machine_config: MachineConfig,
) -> Result<()> {
    match request.protocol() {
        MalaiProtocol::ConfigUpdate => {
            let cluster_dir = machine_config.config_path.parent().unwrap().to_path_buf();
            handle_config_update_protocol(request, cluster_dir).await
        }
        MalaiProtocol::ExecuteCommand => {
            handle_execute_command_protocol(request, machine_config).await  
        }
    }
}

/// Handle config update protocol  
async fn handle_config_update_protocol(
    request: fastn_p2p::server::Request<MalaiProtocol>,
    cluster_dir: std::path::PathBuf,
) -> Result<()> {
    let (config_request, handle): (ConfigSyncRequest, _) = request.get_input().await?;
    
    println!("📥 Config update from: {}", config_request.sender_id52);
    
    // Write received config to machine-config.toml
    let machine_config_path = cluster_dir.join("machine-config.toml");
    std::fs::write(&machine_config_path, &config_request.config_content)?;
    
    println!("💾 Saved machine config to: {}", machine_config_path.display());
    
    // Send success response
    let response = ConfigSyncResponse {
        success: true,
        message: "Config received and saved successfully".to_string(),
    };
    
    handle.send::<ConfigSyncResponse, ConfigSyncError>(Ok(response)).await?;
    
    println!("✅ Config update processed successfully");
    Ok(())
}

/// Handle execute command protocol
async fn handle_execute_command_protocol(
    request: fastn_p2p::server::Request<MalaiProtocol>, 
    machine_config: MachineConfig,
) -> Result<()> {
    let (access_request, handle): (RemoteAccessRequest, _) = request.get_input().await?;
    
    println!("📥 Remote access request from: {}", access_request.client_id52);
    println!("💻 Command: {} {:?}", access_request.command, access_request.args);
    
    // 1. Validate ACL permissions first
    if !validate_command_permission(&access_request, &machine_config).await? {
        let error = RemoteAccessError {
            error_type: "permission_denied".to_string(),
            message: format!("Client {} not authorized to execute '{}' on this machine", 
                           access_request.client_id52, access_request.command),
        };
        
        handle.send::<RemoteAccessResponse, RemoteAccessError>(Err(error)).await?;
        println!("❌ Permission denied for client: {}", access_request.client_id52);
        return Ok(());
    }
    
    println!("✅ Permission granted, executing command...");
    
    // 2. Execute command for real
    use std::time::Instant;
    let start_time = Instant::now();
    
    let execution_result = execute_command_safely(&access_request.command, &access_request.args).await;
    let execution_time = start_time.elapsed().as_millis() as u64;
    
    let response = match execution_result {
        Ok((stdout, stderr, exit_code)) => {
            RemoteAccessResponse {
                stdout,
                stderr,
                exit_code,
                execution_time_ms: execution_time,
            }
        }
        Err(e) => {
            // Command execution failed
            let error_msg = format!("Command execution failed: {}", e);
            RemoteAccessResponse {
                stdout: Vec::new(),
                stderr: error_msg.into_bytes(),
                exit_code: 1,
                execution_time_ms: execution_time,
            }
        }
    };
    
    handle.send::<RemoteAccessResponse, RemoteAccessError>(Ok(response)).await?;
    
    println!("✅ Remote access executed successfully");
    Ok(())
}


/// Unified malai protocol for all P2P communication  
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
enum MalaiProtocol {
    ConfigUpdate,
    ExecuteCommand, 
}

impl std::fmt::Display for MalaiProtocol {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            MalaiProtocol::ConfigUpdate => write!(f, "malai-config-sync"),
            MalaiProtocol::ExecuteCommand => write!(f, "malai-remote-access"),
        }
    }
}

/// Config sync request
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct ConfigSyncRequest {
    sender_id52: String,
    config_content: String,
    timestamp: String,
}

/// Config sync response
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct ConfigSyncResponse {
    success: bool,
    message: String,
}

/// Config sync error
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct ConfigSyncError {
    message: String,
}

impl std::fmt::Display for ConfigSyncError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.message)
    }
}

/// Remote access execute request
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct RemoteAccessRequest {
    client_id52: String,
    machine_alias: String,
    command: String,
    args: Vec<String>,
    timestamp: String,
}

/// Remote access execute response
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct RemoteAccessResponse {
    stdout: Vec<u8>,
    stderr: Vec<u8>,
    exit_code: i32,
    execution_time_ms: u64,
}

/// Remote access error
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct RemoteAccessError {
    error_type: String,
    message: String,
}

impl std::fmt::Display for RemoteAccessError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}: {}", self.error_type, self.message)
    }
}

/// Generate personalized config for a specific machine
pub fn generate_personalized_config(master_config: &str, machine_id52: &str) -> Result<String> {
    // Parse master config
    let master: toml::Value = toml::from_str(master_config)?;
    
    // Find which machine this ID52 corresponds to
    let machine_alias = find_machine_alias_by_id52(&master, machine_id52)?;
    
    // Create personalized config with only relevant sections
    let mut personalized = toml::Value::Table(toml::Table::new());
    
    // 1. Include cluster manager section (always needed)
    if let Some(cluster_manager) = master.get("cluster-manager") {
        personalized.as_table_mut().unwrap()
            .insert("cluster-manager".to_string(), cluster_manager.clone());
    }
    
    // 2. Include this specific machine section
    if let Some(machine_section) = master.get("machine") {
        if let Some(machine_table) = machine_section.as_table() {
            if let Some(this_machine) = machine_table.get(&machine_alias) {
                // Create machine table with just this machine
                let mut machine_map = toml::Table::new();
                machine_map.insert(machine_alias.clone(), this_machine.clone());
                
                personalized.as_table_mut().unwrap()
                    .insert("machine".to_string(), toml::Value::Table(machine_map));
            }
        }
    }
    
    // Convert back to TOML string
    let personalized_config = toml::to_string(&personalized)?;
    
    Ok(personalized_config)
}

/// Find machine alias by machine ID52
fn find_machine_alias_by_id52(config: &toml::Value, machine_id52: &str) -> Result<String> {
    // TOML parser creates nested structure: "machine" -> { "web01" -> { "id52" -> "value" } }
    if let Some(machine_section) = config.get("machine") {
        if let Some(machine_table) = machine_section.as_table() {
            for (machine_alias, machine_config) in machine_table {
                if let Some(machine_config_table) = machine_config.as_table() {
                    if let Some(id52_value) = machine_config_table.get("id52") {
                        if let Some(id52_str) = id52_value.as_str() {
                            if id52_str == machine_id52 {
                                return Ok(machine_alias.clone());
                            }
                        }
                    }
                }
            }
        }
    }
    
    Err(eyre::eyre!("Machine ID52 {} not found in config", machine_id52))
}

/// Send config to machine via P2P
async fn send_config_to_machine_p2p(machine_id52: &str, personalized_config: &str) -> Result<()> {
    println!("📡 Sending config to machine: {}", machine_id52);
    
    // Get cluster manager identity from MALAI_HOME
    let malai_home = get_malai_home();
    let identity_dir = malai_home.join("keys");
    let identity_file = identity_dir.join("identity.key");
    
    if !identity_file.exists() {
        return Err(eyre::eyre!("No cluster manager identity found"));
    }
    
    let secret_key_hex = std::fs::read_to_string(&identity_file)?;
    let cluster_manager_secret = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
    
    // Convert machine ID52 string to PublicKey using FromStr
    let machine_public_key = fastn_id52::PublicKey::from_str(machine_id52)?;
    
    // Create config sync request
    let request = ConfigSyncRequest {
        sender_id52: cluster_manager_secret.id52(),
        config_content: personalized_config.to_string(), 
        timestamp: chrono::Utc::now().to_rfc3339(),
    };
    
    println!("📡 Sending config via fastn_p2p::call...");
    
    // Send config via fastn_p2p
    match fastn_p2p::call::<MalaiProtocol, ConfigSyncRequest, ConfigSyncResponse, ConfigSyncError>(
        cluster_manager_secret,
        &machine_public_key,
        MalaiProtocol::ConfigUpdate,
        request,
    ).await {
        Ok(Ok(response)) => {
            println!("   ✅ Config sent successfully: {}", response.message);
            Ok(())
        }
        Ok(Err(error)) => {
            Err(eyre::eyre!("Config sync error: {}", error.message))
        }
        Err(e) => {
            Err(eyre::eyre!("P2P communication failed: {}", e))
        }
    }
}

/// Send remote access command via P2P
pub async fn send_remote_access_command(machine_address: &str, command: &str, args: Vec<String>) -> Result<()> {
    println!("🧪 Executing remote command...");
    println!("📍 Target: {}", machine_address);
    println!("💻 Command: {} {:?}", command, args);
    
    // Parse machine address to get machine alias and cluster
    let parts: Vec<&str> = machine_address.split('.').collect();
    if parts.len() < 2 {
        return Err(eyre::eyre!("Invalid machine address format: {}", machine_address));
    }
    
    let machine_alias = parts[0];
    let cluster_alias = parts[1];
    
    // Find cluster config to get target machine ID52
    let malai_home = get_malai_home();
    let cluster_dir = malai_home.join("clusters").join(cluster_alias);
    let cluster_config_path = cluster_dir.join("cluster-config.toml");
    
    if !cluster_config_path.exists() {
        return Err(eyre::eyre!("No cluster config found for: {}", cluster_alias));
    }
    
    // Parse cluster config to get target machine ID52  
    let config_content = std::fs::read_to_string(&cluster_config_path)?;
    let config: toml::Value = toml::from_str(&config_content)?;
    
    let target_machine_id52 = if let Some(machine_section) = config.get("machine") {
        if let Some(machine_table) = machine_section.as_table() {
            if let Some(target_machine) = machine_table.get(machine_alias) {
                if let Some(target_table) = target_machine.as_table() {
                    if let Some(id52_value) = target_table.get("id52") {
                        id52_value.as_str().unwrap_or("").to_string()
                    } else {
                        return Err(eyre::eyre!("No id52 found for machine: {}", machine_alias));
                    }
                } else {
                    return Err(eyre::eyre!("Invalid machine config format"));
                }
            } else {
                return Err(eyre::eyre!("Machine {} not found in cluster {}", machine_alias, cluster_alias));
            }
        } else {
            return Err(eyre::eyre!("Invalid config format"));
        }
    } else {
        return Err(eyre::eyre!("No machines section in config"));
    };
    
    println!("🎯 Target machine ID52: {}", target_machine_id52);
    
    // Get local identity (cluster manager uses keys/identity.key)
    let identity_file = malai_home.join("keys").join("identity.key");
    if !identity_file.exists() {
        return Err(eyre::eyre!("No local identity found"));
    }
    
    let secret_key_hex = std::fs::read_to_string(&identity_file)?;
    let local_secret = fastn_id52::SecretKey::from_str(secret_key_hex.trim())?;
    
    // Convert target machine ID52 to public key
    let target_public_key = fastn_id52::PublicKey::from_str(&target_machine_id52)?;
    
    // Create remote access request
    let request = RemoteAccessRequest {
        client_id52: local_secret.id52(),
        machine_alias: machine_alias.to_string(),
        command: command.to_string(),
        args: args.clone(),
        timestamp: chrono::Utc::now().to_rfc3339(),
    };
    
    println!("📡 Sending remote access command via fastn_p2p::call...");
    
    // Send command via fastn_p2p
    match fastn_p2p::call::<MalaiProtocol, RemoteAccessRequest, RemoteAccessResponse, RemoteAccessError>(
        local_secret,
        &target_public_key,
        MalaiProtocol::ExecuteCommand,
        request,
    ).await {
        Ok(Ok(response)) => {
            // Display command output
            if !response.stdout.is_empty() {
                print!("{}", String::from_utf8_lossy(&response.stdout));
            }
            if !response.stderr.is_empty() {
                eprint!("{}", String::from_utf8_lossy(&response.stderr));
            }
            
            if response.exit_code == 0 {
                println!("✅ Remote command executed successfully ({}ms)", response.execution_time_ms);
            } else {
                println!("❌ Remote command failed with exit code: {}", response.exit_code);
            }
            
            Ok(())
        }
        Ok(Err(error)) => {
            Err(eyre::eyre!("Remote access error: {}", error))
        }
        Err(e) => {
            Err(eyre::eyre!("P2P communication failed: {}", e))
        }
    }
}

/// Validate command permission using ACL
async fn validate_command_permission(request: &RemoteAccessRequest, machine_config: &MachineConfig) -> Result<bool> {
    // Parse machine config to check permissions
    let config_content = &machine_config.config_content;
    let config: toml::Value = toml::from_str(config_content)?;
    
    // Find this machine's section in the config
    if let Some(machine_section) = config.get("machine") {
        if let Some(machine_table) = machine_section.as_table() {
            for (_, machine_data) in machine_table {
                if let Some(machine_data_table) = machine_data.as_table() {
                    // Check allow_from for general access
                    if let Some(allow_from_value) = machine_data_table.get("allow_from") {
                        if let Some(allow_from) = allow_from_value.as_str() {
                            println!("🔍 Checking permission: client={}, allow_from='{}'", 
                                   request.client_id52, allow_from);
                            
                            // Simple permission check (TODO: implement group expansion)
                            if allow_from == "*" {
                                println!("✅ Wildcard permission granted");
                                return Ok(true);
                            }
                            
                            // Direct ID match
                            if allow_from.contains(&request.client_id52) {
                                println!("✅ Direct ID permission granted");
                                return Ok(true);
                            }
                            
                            // TODO: Implement group membership checking
                            
                            println!("❌ Permission denied");
                            return Ok(false);
                        }
                    }
                }
            }
        }
    }
    
    println!("❌ No permission configuration found");
    Ok(false)
}

/// Execute command safely with real process execution
async fn execute_command_safely(command: &str, args: &[String]) -> Result<(Vec<u8>, Vec<u8>, i32)> {
    use tokio::process::Command;
    use std::process::Stdio;
    
    println!("🔧 Executing real command: {} {:?}", command, args);
    
    let mut cmd = Command::new(command);
    cmd.args(args)
       .stdout(Stdio::piped())
       .stderr(Stdio::piped());
    
    match cmd.spawn() {
        Ok(child) => {
            match child.wait_with_output().await {
                Ok(output) => {
                    println!("✅ Command completed with exit code: {}", 
                           output.status.code().unwrap_or(-1));
                    Ok((output.stdout, output.stderr, output.status.code().unwrap_or(-1)))
                }
                Err(e) => {
                    Err(eyre::eyre!("Command execution failed: {}", e))
                }
            }
        }
        Err(e) => {
            Err(eyre::eyre!("Failed to spawn command: {}", e))
        }
    }
}
