/// Simple SSH utilities for CLI commands
/// This module provides the basic functionality needed for SSH commands
/// without the complex fastn-p2p integration

use eyre::Result;
use std::path::PathBuf;
use std::str::FromStr;

/// Get MALAI_HOME directory with proper defaults
pub fn get_malai_home() -> PathBuf {
    if let Ok(malai_home) = std::env::var("MALAI_HOME") {
        PathBuf::from(malai_home)
    } else {
        get_default_malai_home()
    }
}

/// Get default MALAI_HOME directory based on platform
pub fn get_default_malai_home() -> PathBuf {
    if let Some(data_dir) = dirs::data_dir() {
        data_dir.join("malai")
    } else {
        // Fallback to current directory
        std::env::current_dir().unwrap_or_default().join(".malai")
    }
}

/// Create cluster configuration
pub async fn create_cluster(alias: Option<String>) -> Result<()> {
    println!("ğŸ—ï¸  Creating SSH cluster...");
    
    let malai_home = get_malai_home();
    let ssh_dir = malai_home.join("ssh");
    
    // Ensure SSH directory exists
    std::fs::create_dir_all(&ssh_dir)?;
    
    // Generate or read existing cluster manager identity
    let identity_dir = malai_home.join("keys");
    std::fs::create_dir_all(&identity_dir)?;
    
    let identity_file = identity_dir.join("identity.key");
    let (cluster_manager_id52, cluster_manager_secret) = if identity_file.exists() {
        // Read existing identity
        let secret_key_hex = std::fs::read_to_string(&identity_file)?;
        let secret_key = kulfi_id52::SecretKey::from_str(&secret_key_hex.trim())?;
        let id52 = secret_key.id52();
        (id52, secret_key)
    } else {
        // Generate new identity
        let (id52, secret_key) = kulfi_utils::generate_secret_key()?;
        // Save to file
        std::fs::write(&identity_file, secret_key.to_string())?;
        (id52, secret_key)
    };
    
    println!("ğŸ“ Generated cluster manager identity: {}", cluster_manager_id52);
    
    // Create basic cluster config
    let cluster_config = format!(
        r#"# Malai SSH Cluster Configuration
# Generated by: malai ssh create-cluster{}
# Cluster Manager: {}

[cluster_manager]
id52 = "{}"
use_keyring = true

# Add machines to this cluster by editing this file
# Examples:

# Basic machine (accepts SSH)
# [machine.web01]
# id52 = "machine-id52-here"
# accept_ssh = true
# allow_from = "*"

# With command aliases
# [machine.web01.command.restart-nginx]
# allow_from = "admins"
# command = "sudo systemctl restart nginx"

# With HTTP services  
# [machine.web01.http.admin]
# port = 8080
# allow_from = "admins"
# secure = false
"#,
        alias.as_ref().map(|a| format!(" --alias {}", a)).unwrap_or_default(),
        cluster_manager_id52,
        cluster_manager_id52
    );
    
    let config_path = ssh_dir.join("cluster-config.toml");
    std::fs::write(&config_path, cluster_config)?;
    
    println!("âœ… Cluster configuration created at: {}", config_path.display());
    println!("Cluster created with ID: {}", cluster_manager_id52);
    
    if let Some(alias) = alias {
        println!("Cluster alias: {}", alias);
    }
    
    Ok(())
}

/// Show cluster information
pub async fn show_cluster_info() -> Result<()> {
    println!("ğŸ“‹ Cluster Information:");
    
    let malai_home = get_malai_home();
    let config_path = malai_home.join("ssh").join("cluster-config.toml");
    
    if !config_path.exists() {
        println!("âŒ No cluster configuration found at: {}", config_path.display());
        println!("ğŸ’¡ Create a cluster with: malai ssh create-cluster");
        return Ok(());
    }
    
    // Read config to determine role
    let config_content = std::fs::read_to_string(&config_path)?;
    println!("ğŸ“„ Config path: {}", config_path.display());
    
    // Parse basic info (simple parsing, not full TOML)
    if let Some(manager_line) = config_content.lines().find(|l| l.starts_with("id52 = ") && !l.contains("[machine.")) {
        let cluster_id = manager_line
            .split('"')
            .nth(1)
            .unwrap_or("unknown");
        println!("ğŸ†” Cluster ID: {}", cluster_id);
        
        // Check local identity to determine role
        let identity_file = malai_home.join("keys").join("identity.key");
        if identity_file.exists() {
            if let Ok(secret_key_hex) = std::fs::read_to_string(&identity_file) {
                if let Ok(secret_key) = kulfi_id52::SecretKey::from_str(secret_key_hex.trim()) {
                    let local_id52 = secret_key.id52();
            
                    if local_id52 == cluster_id {
                        println!("ğŸ‘‘ Role: cluster-manager");
                    } else if config_content.contains(&local_id52) {
                        // Find machine name
                        for line in config_content.lines() {
                            if line.contains(&local_id52) {
                                if let Some(machine_section) = config_content.lines().rev().find(|l| l.starts_with("[machine.") && config_content[config_content.find(l).unwrap()..].contains(&local_id52)) {
                                    let machine_name = machine_section
                                        .trim_start_matches("[machine.")
                                        .trim_end_matches("]");
                                    
                                    let machine_section_start = config_content.find(machine_section).unwrap();
                                    let machine_config = &config_content[machine_section_start..];
                                    if machine_config.split("[").next().unwrap().contains("accept_ssh = true") {
                                        println!("ğŸ–¥ï¸  Role: SSH server ({})", machine_name);
                                    } else {
                                        println!("ğŸ’» Role: client-only ({})", machine_name);
                                    }
                                    break;
                                }
                            }
                        }
                    } else {
                        println!("â“ Role: unknown (not found in cluster config)");
                    }
                }
            }
        }
    }
    
    Ok(())
}

/// Initialize machine for SSH (generates identity, NO config file)
pub async fn init_machine() -> Result<()> {
    println!("ğŸ—ï¸  Initializing machine for SSH...");
    
    let malai_home = get_malai_home();
    let identity_dir = malai_home.join("keys");
    std::fs::create_dir_all(&identity_dir)?;
    
    let identity_file = identity_dir.join("identity.key");
    
    if identity_file.exists() {
        println!("âš ï¸  Machine already initialized");
        let secret_key_hex = std::fs::read_to_string(&identity_file)?;
        let secret_key = kulfi_id52::SecretKey::from_str(secret_key_hex.trim())?;
        let machine_id52 = secret_key.id52();
        println!("ğŸ†” Existing machine ID: {}", machine_id52);
        return Ok(());
    }
    
    // Generate new machine identity
    let (machine_id52, machine_secret) = kulfi_utils::generate_secret_key()?;
    std::fs::write(&identity_file, machine_secret.to_string())?;
    
    println!("ğŸ“ Generated machine identity: {}", machine_id52);
    println!("ğŸ’¾ Identity saved to: {}", identity_file.display());
    println!("Machine created with ID: {}", machine_id52);
    println!("");
    println!("ğŸ“‹ Next steps:");
    println!("1. Share this machine ID with your cluster administrator");
    println!("2. Admin should add this machine to cluster config");
    println!("3. Start agent: malai ssh agent");
    println!("4. Agent will receive config from cluster manager via P2P");
    
    Ok(())
}

/// Execute SSH command on remote machine
pub async fn execute_ssh_command(machine_address: &str, command: &str, args: Vec<String>) -> Result<()> {
    println!("ğŸ§ª Executing SSH command...");
    println!("ğŸ“ Target: {}", machine_address);
    println!("ğŸ’» Command: {} {:?}", command, args);
    
    let malai_home = get_malai_home();
    
    // Check if we have local identity
    let identity_file = malai_home.join("keys").join("identity.key");
    if !identity_file.exists() {
        println!("âŒ No machine identity found");
        println!("ğŸ’¡ Run 'malai ssh init' to initialize this machine");
        return Ok(());
    }
    
    // Check if we have cluster config
    let config_path = malai_home.join("ssh").join("cluster-config.toml");
    if !config_path.exists() {
        println!("âŒ No cluster configuration found");
        println!("ğŸ’¡ Options:");
        println!("   - Initialize cluster: malai ssh init-cluster");
        println!("   - Wait for config from cluster manager");
        return Ok(());
    }
    
    // Parse target machine from address
    let target_machine = parse_machine_address(machine_address)?;
    println!("ğŸ¯ Parsed target: {}", target_machine);
    
    // Check permissions and resolve command
    let resolved_command = resolve_command_permissions(&malai_home, &target_machine, command).await?;
    
    match resolved_command {
        Some(actual_command) => {
            println!("âœ… Permission granted");
            println!("ğŸ”§ Resolved command: {}", actual_command);
            
            // TODO: Execute via P2P communication
            // For now, show what would be executed
            println!("ğŸ“¡ Would execute via P2P: '{}'", actual_command);
            println!("ğŸ¯ Target machine: {}", target_machine);
            
            // Simulate successful execution for now
            println!("âœ… SSH command executed successfully (simulated)");
        }
        None => {
            println!("âŒ Permission denied");
            println!("ğŸ’¡ Contact cluster administrator to add access permissions");
        }
    }
    
    Ok(())
}

/// Parse machine address (web01.cluster-name, web01.cluster-id52, etc.)
fn parse_machine_address(address: &str) -> Result<String> {
    if let Some(machine_part) = address.split('.').next() {
        Ok(machine_part.to_string())
    } else {
        Ok(address.to_string())
    }
}

/// Check permissions and resolve command aliases
async fn resolve_command_permissions(malai_home: &PathBuf, target_machine: &str, command: &str) -> Result<Option<String>> {
    let config_path = malai_home.join("ssh").join("cluster-config.toml");
    let config_content = std::fs::read_to_string(&config_path)?;
    
    // Get local identity
    let identity_file = malai_home.join("keys").join("identity.key");
    let secret_key_hex = std::fs::read_to_string(&identity_file)?;
    let secret_key = kulfi_id52::SecretKey::from_str(secret_key_hex.trim())?;
    let local_id52 = secret_key.id52();
    
    println!("ğŸ” Checking permissions...");
    println!("   Client ID: {}", local_id52);
    println!("   Target machine: {}", target_machine);
    println!("   Command: {}", command);
    
    // Look for command alias first
    let command_alias_section = format!("[machine.{}.command.{}]", target_machine, command);
    if let Some(alias_section_start) = config_content.find(&command_alias_section) {
        println!("ğŸ” Found command alias section: {}", command_alias_section);
        
        // Extract the alias section content
        let remaining = &config_content[alias_section_start..];
        let alias_section = remaining.split("[").next().unwrap_or("");
        
        // Check allow_from for this specific command
        if let Some(allow_line) = alias_section.lines().find(|l| l.trim().starts_with("allow_from")) {
            let allowed = allow_line.split('=').nth(1).unwrap_or("").trim().trim_matches('"');
            if check_access_permission(&config_content, &local_id52, allowed) {
                // Get the actual command to execute
                if let Some(command_line) = alias_section.lines().find(|l| l.trim().starts_with("command")) {
                    let actual_command = command_line.split('=').nth(1).unwrap_or("").trim().trim_matches('"');
                    return Ok(Some(actual_command.to_string()));
                } else {
                    // No command specified, use alias name
                    return Ok(Some(command.to_string()));
                }
            } else {
                println!("âŒ Access denied for command alias: {}", command);
                return Ok(None);
            }
        }
    }
    
    // Check general machine access
    let machine_section = format!("[machine.{}]", target_machine);
    println!("ğŸ” Looking for section: {}", machine_section);
    if let Some(machine_section_start) = config_content.find(&machine_section) {
        println!("âœ… Found machine section at position {}", machine_section_start);
        let remaining = &config_content[machine_section_start..];
        let machine_section = remaining.split("[").next().unwrap_or("");
        
        if let Some(allow_line) = machine_section.lines().find(|l| l.trim().starts_with("allow_from")) {
            let allowed = allow_line.split('=').nth(1).unwrap_or("").trim().trim_matches('"');
            if check_access_permission(&config_content, &local_id52, allowed) {
                println!("âœ… General machine access granted");
                return Ok(Some(command.to_string())); // Use command as-is
            } else {
                println!("âŒ General machine access denied");
                return Ok(None);
            }
        }
    }
    
    println!("âŒ Target machine '{}' not found in cluster config", target_machine);
    Ok(None)
}

/// Check if local machine has access based on allow_from field
fn check_access_permission(config_content: &str, local_id52: &str, allow_from: &str) -> bool {
    println!("ğŸ” Checking access: local_id52={}, allow_from='{}'", local_id52, allow_from);
    
    // Handle wildcard
    if allow_from == "*" {
        println!("âœ… Wildcard access granted");
        return true;
    }
    
    // Split allow_from and check each entry
    for entry in allow_from.split(',') {
        let entry = entry.trim();
        
        // Direct ID match
        if entry == local_id52 {
            println!("âœ… Direct ID match: {}", entry);
            return true;
        }
        
        // Group match (TODO: implement group expansion)
        if expand_group_membership(config_content, entry, local_id52) {
            println!("âœ… Group membership match: {}", entry);
            return true;
        }
    }
    
    println!("âŒ No access permission found");
    false
}

/// Check if local machine is member of group (recursive)
fn expand_group_membership(config_content: &str, group_name: &str, local_id52: &str) -> bool {
    let group_section = format!("[group.{}]", group_name);
    if let Some(group_start) = config_content.find(&group_section) {
        let remaining = &config_content[group_start..];
        let group_section = remaining.split("[").next().unwrap_or("");
        
        if let Some(members_line) = group_section.lines().find(|l| l.trim().starts_with("members")) {
            let members = members_line.split('=').nth(1).unwrap_or("").trim().trim_matches('"');
            
            for member in members.split(',') {
                let member = member.trim();
                
                // Direct ID match
                if member == local_id52 {
                    return true;
                }
                
                // Recursive group check
                if expand_group_membership(config_content, member, local_id52) {
                    return true;
                }
            }
        }
    }
    false
}

/// Start SSH agent with role detection
pub async fn start_ssh_agent(environment: bool, lockdown: bool, http: bool) -> Result<()> {
    let malai_home = get_malai_home();
    
    if environment {
        // Print environment variables for shell integration
        let agent_sock = malai_home.join("ssh").join("agent.sock");
        
        println!("MALAI_SSH_AGENT={}", agent_sock.display());
        
        if lockdown {
            println!("MALAI_LOCKDOWN_MODE=true");
        }
        
        if http {
            println!("HTTP_PROXY=http://127.0.0.1:8080");  // Placeholder port
        }
        
        return Ok(());
    }
    
    println!("ğŸš€ Starting SSH agent...");
    println!("ğŸ“ Using MALAI_HOME: {}", malai_home.display());
    
    // Check for existing agent (lockfile protection)
    let lockfile = malai_home.join("ssh").join("agent.lock");
    if lockfile.exists() {
        println!("ğŸ”’ Agent lockfile exists, checking if agent is running...");
        
        if let Ok(pid_str) = std::fs::read_to_string(&lockfile) {
            if let Ok(pid) = pid_str.trim().parse::<u32>() {
                if is_process_running(pid) {
                    println!("âœ… SSH agent already running (PID: {})", pid);
                    println!("ğŸ’¡ Use 'malai ssh agent -e' to get environment variables");
                    return Ok(());
                } else {
                    println!("ğŸ—‘ï¸  Removing stale lockfile (process {} not running)", pid);
                    let _ = std::fs::remove_file(&lockfile);
                }
            }
        }
    }
    
    // Create lockfile
    let agent_pid = std::process::id();
    std::fs::create_dir_all(lockfile.parent().unwrap())?;
    std::fs::write(&lockfile, agent_pid.to_string())?;
    println!("ğŸ” Created agent lockfile (PID: {})", agent_pid);
    
    // Detect role from cluster config
    let role = detect_machine_role(&malai_home).await?;
    
    match role {
        MachineRole::ClusterManager => {
            println!("ğŸ‘‘ Role detected: Cluster Manager");
            start_cluster_manager_services(&malai_home).await?;
        }
        MachineRole::SshServer(machine_name) => {
            println!("ğŸ–¥ï¸  Role detected: SSH Server ({})", machine_name);
            start_ssh_server_services(&malai_home, &machine_name).await?;
        }
        MachineRole::ClientOnly(machine_name) => {
            println!("ğŸ’» Role detected: Client Only ({})", machine_name);
            start_client_services(&malai_home, &machine_name).await?;
        }
        MachineRole::Unknown => {
            println!("â“ Role: Unknown - no cluster config found or identity not in config");
            println!("ğŸ’¡ Options:");
            println!("   - Create a cluster: malai ssh init-cluster");
            println!("   - Initialize machine: malai ssh init");
            println!("   - Wait for config from cluster manager (if machine already added to cluster)");
            
            // For machines without config, start minimal client services
            println!("ğŸ”§ Starting minimal client services (waiting for config...)");
            // TODO: Start P2P listener to receive config from cluster manager
            
            return Ok(());
        }
    }
    
    println!("âœ… SSH agent started successfully");
    println!("ğŸ’¡ Use 'malai ssh agent -e' to get environment variables for shell integration");
    
    // Keep agent running (in real implementation, this would be an event loop)
    println!("ğŸ”„ Agent running... (press Ctrl+C to stop)");
    
    // Cleanup lockfile on exit
    let lockfile_cleanup = lockfile.clone();
    tokio::spawn(async move {
        tokio::signal::ctrl_c().await.ok();
        let _ = std::fs::remove_file(lockfile_cleanup);
        println!("\nğŸ›‘ SSH agent stopped");
        std::process::exit(0);
    });
    
    // Simple keep-alive loop
    loop {
        tokio::time::sleep(std::time::Duration::from_secs(1)).await;
        // In real implementation, this would handle P2P connections and requests
    }
}

/// Detect machine role from cluster config and local identity
async fn detect_machine_role(malai_home: &PathBuf) -> Result<MachineRole> {
    let config_path = malai_home.join("ssh").join("cluster-config.toml");
    
    if !config_path.exists() {
        return Ok(MachineRole::Unknown);
    }
    
    let config_content = std::fs::read_to_string(&config_path)?;
    let identity_file = malai_home.join("keys").join("identity.key");
    
    if !identity_file.exists() {
        return Ok(MachineRole::Unknown);
    }
    
    let secret_key_hex = std::fs::read_to_string(&identity_file)?;
    let secret_key = kulfi_id52::SecretKey::from_str(secret_key_hex.trim())?;
    let local_id52 = secret_key.id52();
    
    // Parse cluster manager ID
    if let Some(manager_line) = config_content.lines().find(|l| l.starts_with("id52 = ") && !l.contains("[machine.")) {
        let cluster_id = manager_line
            .split('"')
            .nth(1)
            .unwrap_or("");
        
        if local_id52 == cluster_id {
            return Ok(MachineRole::ClusterManager);
        }
    }
    
    // Check if this machine is defined in config
    if config_content.contains(&local_id52) {
        // Find machine name and check accept_ssh
        for line in config_content.lines() {
            if line.starts_with("[machine.") && config_content[config_content.find(line).unwrap()..].contains(&local_id52) {
                let machine_name = line
                    .trim_start_matches("[machine.")
                    .trim_end_matches("]");
                
                // Check if this machine accepts SSH connections
                let machine_section_start = config_content.find(line).unwrap();
                let remaining_config = &config_content[machine_section_start..];
                let machine_section = remaining_config.split("[").next().unwrap();
                
                if machine_section.contains("accept_ssh = true") {
                    return Ok(MachineRole::SshServer(machine_name.to_string()));
                } else {
                    return Ok(MachineRole::ClientOnly(machine_name.to_string()));
                }
            }
        }
    }
    
    Ok(MachineRole::Unknown)
}

/// Machine roles for agent
#[derive(Debug, PartialEq)]
enum MachineRole {
    ClusterManager,
    SshServer(String),
    ClientOnly(String), 
    Unknown,
}

/// Start cluster manager specific services
async fn start_cluster_manager_services(malai_home: &PathBuf) -> Result<()> {
    println!("ğŸ”§ Starting cluster manager services...");
    println!("   ğŸ“‚ Config monitoring: {}/ssh/cluster-config.toml", malai_home.display());
    println!("   ğŸŒ P2P coordination: cluster member management");
    println!("   ğŸ“¤ Config distribution: syncing to all cluster machines");
    
    // TODO: Implement actual cluster manager functionality
    // - Watch config file for changes
    // - Distribute config updates to cluster members
    // - Handle member registration and coordination
    
    Ok(())
}

/// Start SSH server specific services
async fn start_ssh_server_services(malai_home: &PathBuf, machine_name: &str) -> Result<()> {
    println!("ğŸ”§ Starting SSH server services for machine '{}'...", machine_name);
    println!("   ğŸšª SSH listener: accepting incoming connections");
    println!("   ğŸŒ P2P communication: fastn-p2p protocol handling");
    println!("   ğŸ” Permission checking: command and service access control");
    
    // TODO: Implement actual SSH server functionality
    // - Listen for incoming SSH connections via fastn-p2p
    // - Execute authorized commands
    // - Proxy HTTP services with access control
    
    Ok(())
}

/// Start client-only services  
async fn start_client_services(malai_home: &PathBuf, machine_name: &str) -> Result<()> {
    println!("ğŸ”§ Starting client services for machine '{}'...", machine_name);
    println!("   ğŸŒ P2P client: outbound connection management");
    println!("   ğŸ•¸ï¸  HTTP proxy: transparent service access");
    println!("   ğŸ”§ Connection pooling: efficient remote access");
    
    // TODO: Implement actual client functionality
    // - HTTP proxy for transparent service access
    // - Connection pooling for SSH commands
    // - Config sync from cluster manager
    
    Ok(())
}

/// Check if a process is running (safe approach)
fn is_process_running(pid: u32) -> bool {
    // Safe approach: check if /proc/pid exists (Linux/macOS)
    #[cfg(unix)]
    {
        std::path::Path::new(&format!("/proc/{}", pid)).exists()
    }
    
    #[cfg(not(unix))]
    {
        // On Windows, assume process might be running
        // In real implementation, would use Windows APIs
        false
    }
}