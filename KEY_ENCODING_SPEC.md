# Key Encoding Specification and Compatibility

This document describes the key encoding formats used in kulfi-utils and ensures backward compatibility.

## Encoding Formats

### Secret Keys
- **Storage Format**: Hexadecimal (lowercase), 64 characters
- **Display Implementation**: `data_encoding::HEXLOWER.encode(&bytes)`
- **Parsing**: Accepts both:
  - Hex format (64 chars) - primary format
  - BASE32_NOPAD format - for backward compatibility with iroh's alternative format

### Public Keys (ID52)
- **Storage Format**: BASE32_DNSSEC encoding, 52 characters
- **Display Implementation**: `data_encoding::BASE32_DNSSEC.encode(&bytes)`
- **Parsing**: BASE32_DNSSEC decoding

## Compatibility Guarantees

1. **Secret keys stored in hex format will always be readable**
   - Example: `100d7e23f222267ba0be43855a262461b8a7718572edf58c56db912156d2bc25`

2. **Public keys (ID52) maintain consistent encoding**
   - Example: `i66fo538lfl5ombdf6tcdbrabp4hmp9asv7nrffuc2im13ct4q60`

3. **Round-trip guarantee**: 
   - `parse(encode(key)) == key` for all valid keys
   - `encode(parse(str)) == str` for all valid encoded strings

## Test Coverage

The compatibility test suite includes:

### `baseline_compat` tests:
- Loading keys generated by baseline malai keygen
- Verifying ID52 matches between versions
- Testing signature generation and verification
- Ensuring encoding roundtrips correctly

### `baseline_compatibility` tests:
- Secret key hex encoding/decoding
- Secret key roundtrip (generate → encode → decode → encode)  
- Public key ID52 encoding/decoding
- Bytes representation compatibility
- Cross-version compatibility verification

### Test Keys
Baseline test keys are stored in `test-keys/` directory:
- **key-1.txt**: `100d7e23f222267ba0be43855a262461b8a7718572edf58c56db912156d2bc25` → `i66fo538lfl5ombdf6tcdbrabp4hmp9asv7nrffuc2im13ct4q60`
- **key-2.txt**: `e357e8a31fa82958cf0a7697846cb9ed494807d5d8bf95bac9ed21207d8ce6a3` → `e87aeds2fajaeu10tjdio5ppcdha410n6tu4665u7el9as9b7v80` 
- **key-3.txt**: `a0ed7d4cdd3a2941a289f6bde83717898cccde35b0a8c2944aba66f87a2dcfa9` → `mlk9ubnvu8r1sk06j4tjb98njra0od5d2dglpm8gubbvg4glthng`

These were generated using malai keygen from commit 11d4d3f and verified to work with current implementation.

## Migration Notes

When updating kulfi-utils:
1. Run `cargo test -p kulfi-utils -- baseline_compat baseline_compatibility`
2. Add any new test vectors from production keys  
3. Never change the encoding format without a migration plan
4. Always verify baseline keys still work after changes

## Implementation Details

The encoding logic is centralized in `kulfi-utils/src/keys.rs`:
- `SecretKey` newtype wrapper handles all secret key encoding/signing
- `PublicKey` newtype wrapper handles all public key encoding/verification  
- `Signature` newtype wrapper handles ed25519 signatures
- Conditional compilation supports both iroh and ed25519-dalek backends
- Direct access to underlying types is restricted to maintain consistency

### Type System
```rust
pub struct PublicKey(InnerPublicKey);   // Uses BASE32_DNSSEC for Display/FromStr
pub struct SecretKey(InnerSecretKey);   // Uses HEXLOWER for Display, accepts hex+base32 in FromStr
pub struct Signature(ed25519_dalek::Signature);  // ed25519 signatures

// Backend support via conditional compilation:
#[cfg(feature = "iroh")]
type InnerPublicKey = iroh::PublicKey;
#[cfg(not(feature = "iroh"))] 
type InnerPublicKey = ed25519_dalek::VerifyingKey;
```

This ensures encoding compatibility regardless of whether iroh feature is enabled.